grammar org.osate.altarica.Altarica with org.eclipse.xtext.common.Terminals

generate altarica "http://osate.org/Altarica/2.1"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model:
	declarations+=AbstractDeclaration*;

AbstractDeclaration:
	Domain | Class;

ConstantDefinition returns NamedElement:
	{ConstantDefinition}
	'const' name=ID expression=AbstractDefinitionConstant ';';

AbstractDefinitionConstant:
	ExpressionConstant | DomainConstant;

ExpressionConstant:
	'=' ownedExpression=Expression;

DomainConstant:
	':' domain=AbstractDomain ('=' ownedExpression=Expression)?;

Domain returns NamedElement:
	{Domain}
	'domain' name=ID domain=Enumeration ';';

AbstractDomain:
	BaseType | Range | Enumeration;

Range:
	'[' lower=Atom ',' upper=Atom ']';

Enumeration:
	{Enumeration} '{' ( ownedSymbols+=SymbolicConstant (',' ownedSymbols+=SymbolicConstant)* )? '}';

SymbolicConstant returns NamedElement:
	{SymbolicConstant} name=ID;




Type:
	=>BaseType | NamedType
;

BaseType:
	name=BaseTypeEnum;

enum BaseTypeEnum:
	INTEGER='Integer' | BOOLEAN='Boolean';

NamedType:
	ref=[NamedElement|ID]
;

// ========== Classes ==========

Class returns NamedElement:
	{Node}
	'class' name=ID
		declarations+=Declaration*
		(
		  "transition"
		  transitions+=LabeledTransition+
		)?
		(
		  "assertion"
		  assertions+=Instruction+
		)?
	'end'
;

// ========== Declarations ==========

Declaration:
	VariableDeclaration | EventDeclaration | ParameterDeclaration | ObserverDeclaration
;


VariableDeclaration returns NamedElement:
	{Variable}
	type=Type name=ID 
	( "(" attributes+=Attribute ("," attributes+=Attribute)* ")" )?
	";"
;
	
Attribute returns NamedElement:
	{Attribute}
	name=ID "=" value=Expression
	";"
;
	

EventDeclaration returns NamedElement:
	{Event}
	"event" name=ID	
	( "(" attributes+=Attribute ("," attributes+=Attribute)* ")" )?
	";"
;


ParameterDeclaration returns NamedElement:
	{Parameter}
	"parameter" type=Type name=ID "=" value=Expression
	";"
;


ObserverDeclaration returns NamedElement:
	{Observer}
	"observer" type=Type name=ID "=" value=Expression
	";"
;

// ========== Transitions ==========

LabeledTransition:
	event=NameRef ":" expression=TransitionAnd
;

TransitionAnd returns TransitionExpression:
	TransitionOr ({TransitionAnd.left=current} '&' right=TransitionOr)*;

TransitionOr returns TransitionExpression:
	ITransition ({TransitionOr.left=current} '|' right=ITransition)*;

ITransition:
	{ITransition}
	"$transition"
;

// ========== Instructions ==========

Instruction:
	Skip | Assignment | Block | IfThenElse
;

Skip returns Instruction:
	{Skip} 
	'skip' ';'
;

Assignment returns Instruction:
	{Assignment}
	variable=NameRef ':=' value=Expression ';'
;

Block returns Instruction:
	{Block}
	'{' (instructions+=Instruction)+ '}'
;

IfThenElse:
	'if' condition=Expression 'then' then=Instruction (=>'else' else=Instruction)? ";"
;

// ========== Expressions ==========

Expression:
	Logical
;
	
Logical returns Expression:
	Relation =>({Logical.left=current} op=('and' | 'or') right=Relation)*
;

Relation returns Expression:
	Addition =>({Equal.left=current} op=('='|'!=' | '<' | '<=' | '>=' | '>') right=Addition)*
;

Addition returns Expression:
	Multiplication =>({Addition.left=current} op=('+' | '-') right=Multiplication)*
;

Multiplication returns Expression:
	Neg =>({Multiplication.left=current} op=('*' | '/') right=Neg)*
;

Neg returns Expression:
	{Not} =>'not' expression=Atom
	| {Minus} =>'-' expression=Atom 
	| Atom
;

Atom returns Expression:
	BooleanLiteral | StringLiteral | IntegerLiteral | NameRef | '(' Expression ')'
;

BooleanLiteral returns ARBoolean:
	value=('true' | 'false');

StringLiteral returns ARString:
	value=STRING;

IntegerLiteral returns ARInteger:
	value=INT;

NameRef:
	variable=[NamedElement] =>({NameRef.nested=current} '.' variable=[NamedElement])*;

//================

VariableAttribute:
	name=ID;

//terminal Directive returns ecore::EString : "/*" -> ";";

AbstractTypeRef:
	DomainRef | AbstractDomain;

DomainRef:
	reference=[Domain];


//Assignment:
//	state=[State] ':=' ownedExpression=AbstractExpression;

AbstractExpression:
	IfThenElse| Switch | Expression;

Switch:
	'case {' 
		ownedCases+=CaseExpression*
	'else'
		default=Expression
	'}';

CaseExpression:
	condition=Expression ':' body=Expression ',';

//===== Terminals

terminal fragment ALPHA: 'a'..'z'|'A'..'Z';

terminal fragment DIGIT: '0'..'9';

terminal fragment REGULAR_ID: (ALPHA|'_')(ALPHA |'_'| DIGIT)*;

terminal fragment STRING_ID: "'" (
		ALPHA | DIGIT | '!' | '#' | '$'  | '%' | '&' | '(' | ')' | '*' | '+' | ',' | '-' 
		| '.' | '/' | ':' | ';' | '<' | '>' | '=' | '?' | '@' | '[' | ']' | '^' | '{' | '}' | '|' | '~' | '_'
	)*  "'";

terminal ID:
	REGULAR_ID | STRING_ID;

terminal STRING  : 
	'"' ( '\\'('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|"'") )* '"';
