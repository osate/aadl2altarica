/*******************************************************************************
* Copyright (c) 2011-2012 Frédéric Thomas.
* All rights reserved. This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl-v10.html
*
* Contributors:
* fthomas - initial grammar
*******************************************************************************/

grammar org.osate.altarica.Altarica with org.eclipse.xtext.common.Terminals

generate altarica "http://osate.org/Altarica"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

System:
	ownedDeclarations+=AbstractDeclaration*;

AbstractDeclaration:
	Domain | ConstantDefinition | Node;

ConstantDefinition returns NamedElement:
	{ConstantDefinition}
	'const' name=ID expression=AbstractDefinitionConstant ';';

AbstractDefinitionConstant:
	ExpressionConstant | DomainConstant;

ExpressionConstant:
	'=' ownedExpression=Expression;

DomainConstant:
	':' domain=AbstractDomain ('=' ownedExpression=Expression)?;

Domain returns NamedElement:
	{Domain}
	'domain' name=ID '=' domain=AbstractDomain ';';

AbstractDomain:
	PrimitiveType | Range | Enumeration;

Range:
	'[' lower=Atom ',' upper=Atom ']';

Enumeration:
	'{' ownedLiterals+=Literal (',' ownedLiterals+=Literal)* '}';

PrimitiveType:
	name=PrimitiveTypeKind;

enum PrimitiveTypeKind:
	INTEGER='integer' | BOOLEAN='bool';

Literal returns NamedElement:
	{EnumerationLiteral} name=ID;

Node returns NamedElement:
	{Node}
	'node' name=ID 
		ownedSpecifications+=AbstractSpecification*
	'edon';

AbstractSpecification:
	FlowSpecification | StateSpecification | EventSpecification | NodeInstanceSpecification | AssertSpecification |
	VectorSpecification | TransitionSpecification | InitSpecification | ExternalSpecification;

VariableAttribute:
	name=ID;

InitSpecification:
	'init' ownedInitStatements+=InitStatement*;

InitStatement:
	affectation=Assignment ";";

ExternalSpecification:
	'extern' ownedDirectives+=ExternalDirective*;

ExternalDirective:
	directive = SL_COMMENT;

//terminal Directive returns ecore::EString : "/*" -> ";";

FlowSpecification:
	'flow' ownedFlows+=Flow*;

Flow returns NamedElement:
	{Flow}
	name=ID ':' domain=AbstractTypeRef (':' kind=FlowKind)? (':' attribute=VariableAttribute)? ";";

enum FlowKind:
	IN='in' | OUT='out' | INOUT='inout';

enum VisibilityKind:
	PUBLIC='public' | PRIVATE='private' | PARENT='parent';

EventSpecification:
	'event' ownedEvents+=Event*;

Event returns NamedElement:
	{Event}
	name=ID ('[' ownedPriority=Priority ']')? (':' attribute=VariableAttribute)? ';';

Priority:
	('!' | 'priority') ownedExpression=AbstractExpression;

StateSpecification:
	'state' ownedStates+=State*;

State returns NamedElement:
	{State}
	name=ID ':' domain=AbstractTypeRef (':' attribute=VariableAttribute)? ";";

AbstractTypeRef:
	DomainRef | AbstractDomain;

DomainRef:
	reference=[Domain];

NodeInstanceSpecification:
	'sub' ownedNodeInstances+=NodeInstance*;

NodeInstance returns NamedElement:
	{NodeInstance}
	name=ID ':' nodeType=[Node] ";";

AssertSpecification:
	'assert' ownedAsserts+=Assert*;

Assert:
	ownedExpressions+=AbstractBooleanExpression ";";

VectorSpecification:
	'sync' ownedVectors+=Vector*;

Vector:
	'<' ownedParameters+=VectorParameter (',' ownedParameters+=VectorParameter)* '>' ('[' cardinality=Cardinality ']')? ";";

VectorParameter:
	eventParameter= EventRef (isRequired?='?')?;

Cardinality:
	('>' expression=AbstractExpression) | ('>=' expression=AbstractExpression) | ('=' expression=AbstractExpression);

TransitionSpecification:
	'trans' ownedTransitionTransitions+=Transition*;

Transition:
	ownedExpression=AbstractExpression '|-' event=[Event] '->' (ownedAffectations+=Assignment (','
	ownedAffectations+=Assignment)*)* ";";

Assignment:
	state=[State] ':=' ownedExpression=AbstractExpression;

AbstractExpression:
	IfThenElse| Switch | Expression;

AbstractBooleanExpression:
	IfThenElse| Switch | BooleanExpression;
	
Switch:
	'case {' 
		ownedCases+=CaseExpression*
	'else'
		default=Expression
	'}';

CaseExpression:
	condition=BooleanExpression ':' body=Expression ',';

IfThenElse:
	'if' condition=BooleanExpression 'then' then=(Switch | Expression) 'else' else=(Switch | Expression);

Expression :
	Minus ({Addition.leftOperand=current} '+' rightOperand=Minus)*;

Minus returns Expression:
	Multiplication ({Minus.leftOperand=current} '-' rightOperand=Multiplication)*;

Multiplication returns Expression:
	Division ({Multiplication.leftOperand=current} '*' rightOperand=Division)*;

Division returns Expression:
	 BooleanExpression ({Division.leftOperand=current} '/' rightOperand=BooleanExpression)*;



BooleanExpression returns Expression:
	And;
	
And returns Expression:
	Or ({And.leftOperand=current} ('and'|'&') rightOperand=Or)*;

Or returns Expression:
	Equal ({Or.leftOperand=current} ('or'|'|') rightOperand=Equal)*;

Equal returns Expression:
	NotEqual ({Equal.leftOperand=current} '=' rightOperand=NotEqual)*;

NotEqual returns Expression:
	StrictLower ({NotEqual.leftOperand=current} '!=' rightOperand=StrictLower)*;

StrictLower returns Expression:
	Lower ({StrictLower.leftOperand=current} '<' rightOperand=Lower)*;

Lower returns Expression:
	StrictUpper ({Lower.leftOperand=current} '<=' rightOperand=StrictUpper)*;

StrictUpper returns Expression:
	Upper ({StrictUpper.leftOperand=current} '>' rightOperand=Upper)*;

Upper returns Expression:
	Imply ({Upper.leftOperand=current} '>=' rightOperand=Imply)*;

Imply returns Expression:
	Not ({Imply.leftOperand=current} '=>' rightOperand=Not)*;

Not returns Expression:
	(('~'|'not')operand = Atom) | Atom;

Atom returns Expression:
	BooleanLiteral | StringLiteral | IntegerLiteral | VariableRef | '(' Expression ')';

EventRef:
	variable=[NamedElement] ({NestedQualifiedEventRef.target=current} '.' nestedVariable=[NamedElement])*; //('.' ownedFeature=QualifiedEventRef)?;

VariableRef:
	variable=[NamedElement] ({NestedQualifiedVariableRef.target=current} '.' nestedVariable=[NamedElement])*;

BooleanLiteral returns ARBoolean:
	value=('true' | 'false');

StringLiteral returns ARString:
	value=STRING;

IntegerLiteral returns ARInteger:
	value=INT;