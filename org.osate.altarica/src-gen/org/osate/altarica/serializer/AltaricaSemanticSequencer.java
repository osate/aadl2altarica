/*
 * generated by Xtext
 */
package org.osate.altarica.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.osate.altarica.altarica.ARBoolean;
import org.osate.altarica.altarica.ARInteger;
import org.osate.altarica.altarica.ARString;
import org.osate.altarica.altarica.Addition;
import org.osate.altarica.altarica.AltaricaPackage;
import org.osate.altarica.altarica.Assignment;
import org.osate.altarica.altarica.Attribute;
import org.osate.altarica.altarica.BaseType;
import org.osate.altarica.altarica.Block;
import org.osate.altarica.altarica.CaseExpression;
import org.osate.altarica.altarica.ClassType;
import org.osate.altarica.altarica.ConstantDefinition;
import org.osate.altarica.altarica.Domain;
import org.osate.altarica.altarica.DomainConstant;
import org.osate.altarica.altarica.DomainRef;
import org.osate.altarica.altarica.Enumeration;
import org.osate.altarica.altarica.EnumerationLiteral;
import org.osate.altarica.altarica.Equal;
import org.osate.altarica.altarica.Event;
import org.osate.altarica.altarica.ExpressionConstant;
import org.osate.altarica.altarica.ITransition;
import org.osate.altarica.altarica.IfThenElse;
import org.osate.altarica.altarica.LabeledTransition;
import org.osate.altarica.altarica.Logical;
import org.osate.altarica.altarica.Minus;
import org.osate.altarica.altarica.Model;
import org.osate.altarica.altarica.Multiplication;
import org.osate.altarica.altarica.NameRef;
import org.osate.altarica.altarica.NestedRef;
import org.osate.altarica.altarica.Node;
import org.osate.altarica.altarica.Not;
import org.osate.altarica.altarica.Observer;
import org.osate.altarica.altarica.Parameter;
import org.osate.altarica.altarica.Range;
import org.osate.altarica.altarica.Skip;
import org.osate.altarica.altarica.Switch;
import org.osate.altarica.altarica.TransitionAnd;
import org.osate.altarica.altarica.TransitionOr;
import org.osate.altarica.altarica.Variable;
import org.osate.altarica.altarica.VariableAttribute;
import org.osate.altarica.services.AltaricaGrammarAccess;

@SuppressWarnings("all")
public class AltaricaSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AltaricaGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == AltaricaPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case AltaricaPackage.AR_BOOLEAN:
				sequence_BooleanLiteral(context, (ARBoolean) semanticObject); 
				return; 
			case AltaricaPackage.AR_INTEGER:
				sequence_IntegerLiteral(context, (ARInteger) semanticObject); 
				return; 
			case AltaricaPackage.AR_STRING:
				sequence_StringLiteral(context, (ARString) semanticObject); 
				return; 
			case AltaricaPackage.ADDITION:
				sequence_Addition(context, (Addition) semanticObject); 
				return; 
			case AltaricaPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case AltaricaPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case AltaricaPackage.BASE_TYPE:
				sequence_BaseType(context, (BaseType) semanticObject); 
				return; 
			case AltaricaPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case AltaricaPackage.CASE_EXPRESSION:
				sequence_CaseExpression(context, (CaseExpression) semanticObject); 
				return; 
			case AltaricaPackage.CLASS_TYPE:
				sequence_ClassType(context, (ClassType) semanticObject); 
				return; 
			case AltaricaPackage.CONSTANT_DEFINITION:
				sequence_ConstantDefinition(context, (ConstantDefinition) semanticObject); 
				return; 
			case AltaricaPackage.DOMAIN:
				sequence_Domain(context, (Domain) semanticObject); 
				return; 
			case AltaricaPackage.DOMAIN_CONSTANT:
				sequence_DomainConstant(context, (DomainConstant) semanticObject); 
				return; 
			case AltaricaPackage.DOMAIN_REF:
				sequence_DomainRef(context, (DomainRef) semanticObject); 
				return; 
			case AltaricaPackage.ENUMERATION:
				sequence_Enumeration(context, (Enumeration) semanticObject); 
				return; 
			case AltaricaPackage.ENUMERATION_LITERAL:
				sequence_Literal(context, (EnumerationLiteral) semanticObject); 
				return; 
			case AltaricaPackage.EQUAL:
				sequence_Relation(context, (Equal) semanticObject); 
				return; 
			case AltaricaPackage.EVENT:
				sequence_EventDeclaration(context, (Event) semanticObject); 
				return; 
			case AltaricaPackage.EXPRESSION_CONSTANT:
				sequence_ExpressionConstant(context, (ExpressionConstant) semanticObject); 
				return; 
			case AltaricaPackage.ITRANSITION:
				sequence_ITransition(context, (ITransition) semanticObject); 
				return; 
			case AltaricaPackage.IF_THEN_ELSE:
				sequence_IfThenElse(context, (IfThenElse) semanticObject); 
				return; 
			case AltaricaPackage.LABELED_TRANSITION:
				sequence_LabeledTransition(context, (LabeledTransition) semanticObject); 
				return; 
			case AltaricaPackage.LOGICAL:
				sequence_Logical(context, (Logical) semanticObject); 
				return; 
			case AltaricaPackage.MINUS:
				sequence_Neg(context, (Minus) semanticObject); 
				return; 
			case AltaricaPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case AltaricaPackage.MULTIPLICATION:
				sequence_Multiplication(context, (Multiplication) semanticObject); 
				return; 
			case AltaricaPackage.NAME_REF:
				sequence_NameRef(context, (NameRef) semanticObject); 
				return; 
			case AltaricaPackage.NESTED_REF:
				sequence_NameRef(context, (NestedRef) semanticObject); 
				return; 
			case AltaricaPackage.NODE:
				sequence_Class(context, (Node) semanticObject); 
				return; 
			case AltaricaPackage.NOT:
				sequence_Neg(context, (Not) semanticObject); 
				return; 
			case AltaricaPackage.OBSERVER:
				sequence_ObserverDeclaration(context, (Observer) semanticObject); 
				return; 
			case AltaricaPackage.PARAMETER:
				sequence_ParameterDeclaration(context, (Parameter) semanticObject); 
				return; 
			case AltaricaPackage.RANGE:
				sequence_Range(context, (Range) semanticObject); 
				return; 
			case AltaricaPackage.SKIP:
				sequence_Skip(context, (Skip) semanticObject); 
				return; 
			case AltaricaPackage.SWITCH:
				sequence_Switch(context, (Switch) semanticObject); 
				return; 
			case AltaricaPackage.TRANSITION_AND:
				sequence_TransitionAnd(context, (TransitionAnd) semanticObject); 
				return; 
			case AltaricaPackage.TRANSITION_OR:
				sequence_TransitionOr(context, (TransitionOr) semanticObject); 
				return; 
			case AltaricaPackage.VARIABLE:
				sequence_VariableDeclaration(context, (Variable) semanticObject); 
				return; 
			case AltaricaPackage.VARIABLE_ATTRIBUTE:
				sequence_VariableAttribute(context, (VariableAttribute) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (left=Addition_Addition_1_0_0 (op='+' | op='-') right=Multiplication)
	 */
	protected void sequence_Addition(EObject context, Addition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (variable=NameRef value=Expression)
	 */
	protected void sequence_Assignment(EObject context, Assignment semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.ASSIGNMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.ASSIGNMENT__VARIABLE));
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.ASSIGNMENT__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAssignmentAccess().getVariableNameRefParserRuleCall_1_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getAssignmentAccess().getValueExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID value=Expression)
	 */
	protected void sequence_Attribute(EObject context, Attribute semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.NAMED_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.ATTRIBUTE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.ATTRIBUTE__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAttributeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAttributeAccess().getValueExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=BaseTypeEnum
	 */
	protected void sequence_BaseType(EObject context, BaseType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.BASE_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.BASE_TYPE__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBaseTypeAccess().getNameBaseTypeEnumEnumRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     instructions+=Instruction+
	 */
	protected void sequence_Block(EObject context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_BooleanLiteral(EObject context, ARBoolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (condition=Expression body=Expression)
	 */
	protected void sequence_CaseExpression(EObject context, CaseExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.CASE_EXPRESSION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.CASE_EXPRESSION__CONDITION));
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.CASE_EXPRESSION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.CASE_EXPRESSION__BODY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCaseExpressionAccess().getConditionExpressionParserRuleCall_0_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getCaseExpressionAccess().getBodyExpressionParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     class=[Node|ID]
	 */
	protected void sequence_ClassType(EObject context, ClassType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.CLASS_TYPE__CLASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.CLASS_TYPE__CLASS));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getClassTypeAccess().getClassNodeIDTerminalRuleCall_0_1(), semanticObject.getClass_());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID declarations+=Declaration* transitions+=LabeledTransition* assertions+=Instruction*)
	 */
	protected void sequence_Class(EObject context, Node semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID expression=AbstractDefinitionConstant)
	 */
	protected void sequence_ConstantDefinition(EObject context, ConstantDefinition semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.NAMED_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.CONSTANT_DEFINITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.CONSTANT_DEFINITION__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getConstantDefinitionAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getConstantDefinitionAccess().getExpressionAbstractDefinitionConstantParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (domain=AbstractDomain ownedExpression=Expression?)
	 */
	protected void sequence_DomainConstant(EObject context, DomainConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     reference=[Domain|ID]
	 */
	protected void sequence_DomainRef(EObject context, DomainRef semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.DOMAIN_REF__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.DOMAIN_REF__REFERENCE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDomainRefAccess().getReferenceDomainIDTerminalRuleCall_0_1(), semanticObject.getReference());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID domain=AbstractDomain)
	 */
	protected void sequence_Domain(EObject context, Domain semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.NAMED_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.DOMAIN__DOMAIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.DOMAIN__DOMAIN));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDomainAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDomainAccess().getDomainAbstractDomainParserRuleCall_4_0(), semanticObject.getDomain());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (ownedLiterals+=Literal ownedLiterals+=Literal*)
	 */
	protected void sequence_Enumeration(EObject context, Enumeration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID (attributes+=Attribute attributes+=Attribute*)?)
	 */
	protected void sequence_EventDeclaration(EObject context, Event semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ownedExpression=Expression
	 */
	protected void sequence_ExpressionConstant(EObject context, ExpressionConstant semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.ABSTRACT_DEFINITION_CONSTANT__OWNED_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.ABSTRACT_DEFINITION_CONSTANT__OWNED_EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExpressionConstantAccess().getOwnedExpressionExpressionParserRuleCall_1_0(), semanticObject.getOwnedExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {ITransition}
	 */
	protected void sequence_ITransition(EObject context, ITransition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (condition=Expression then=Instruction else=Instruction?)
	 */
	protected void sequence_IfThenElse(EObject context, IfThenElse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_IntegerLiteral(EObject context, ARInteger semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.AR_INTEGER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.AR_INTEGER__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIntegerLiteralAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (event=NameRef expression=TransitionAnd)
	 */
	protected void sequence_LabeledTransition(EObject context, LabeledTransition semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.LABELED_TRANSITION__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.LABELED_TRANSITION__EVENT));
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.LABELED_TRANSITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.LABELED_TRANSITION__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getLabeledTransitionAccess().getEventNameRefParserRuleCall_0_0(), semanticObject.getEvent());
		feeder.accept(grammarAccess.getLabeledTransitionAccess().getExpressionTransitionAndParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Literal(EObject context, EnumerationLiteral semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.NAMED_ELEMENT__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getLiteralAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=Logical_Logical_1_0_0 (op='and' | op='or') right=Relation)
	 */
	protected void sequence_Logical(EObject context, Logical semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     declarations+=AbstractDeclaration*
	 */
	protected void sequence_Model(EObject context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=Multiplication_Multiplication_1_0_0 (op='*' | op='/') right=Neg)
	 */
	protected void sequence_Multiplication(EObject context, Multiplication semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     variable=[NamedElement|ID]
	 */
	protected void sequence_NameRef(EObject context, NameRef semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.NAME_REF__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.NAME_REF__VARIABLE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNameRefAccess().getVariableNamedElementIDTerminalRuleCall_0_0_1(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (target=NameRef_NestedRef_1_0_0 nested=NameRef)
	 */
	protected void sequence_NameRef(EObject context, NestedRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expression=Atom
	 */
	protected void sequence_Neg(EObject context, Minus semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.MINUS__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.MINUS__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNegAccess().getExpressionAtomParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expression=Atom
	 */
	protected void sequence_Neg(EObject context, Not semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.NOT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.NOT__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNegAccess().getExpressionAtomParserRuleCall_0_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (type=Type name=ID value=Expression)
	 */
	protected void sequence_ObserverDeclaration(EObject context, Observer semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.NAMED_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.OBSERVER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.OBSERVER__TYPE));
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.OBSERVER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.OBSERVER__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getObserverDeclarationAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getObserverDeclarationAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getObserverDeclarationAccess().getValueExpressionParserRuleCall_5_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (type=Type name=ID value=Expression)
	 */
	protected void sequence_ParameterDeclaration(EObject context, Parameter semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.NAMED_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.PARAMETER__TYPE));
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.PARAMETER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.PARAMETER__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getParameterDeclarationAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getParameterDeclarationAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParameterDeclarationAccess().getValueExpressionParserRuleCall_5_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (lower=Atom upper=Atom)
	 */
	protected void sequence_Range(EObject context, Range semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.RANGE__LOWER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.RANGE__LOWER));
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.RANGE__UPPER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.RANGE__UPPER));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRangeAccess().getLowerAtomParserRuleCall_1_0(), semanticObject.getLower());
		feeder.accept(grammarAccess.getRangeAccess().getUpperAtomParserRuleCall_3_0(), semanticObject.getUpper());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         left=Relation_Equal_1_0_0 
	 *         (
	 *             op='=' | 
	 *             op='!=' | 
	 *             op='<' | 
	 *             op='<=' | 
	 *             op='>=' | 
	 *             op='>'
	 *         ) 
	 *         right=Addition
	 *     )
	 */
	protected void sequence_Relation(EObject context, Equal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {Skip}
	 */
	protected void sequence_Skip(EObject context, Skip semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteral(EObject context, ARString semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.AR_STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.AR_STRING__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (ownedCases+=CaseExpression* default=Expression)
	 */
	protected void sequence_Switch(EObject context, Switch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=TransitionAnd_TransitionAnd_1_0 right=TransitionOr)
	 */
	protected void sequence_TransitionAnd(EObject context, TransitionAnd semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.TRANSITION_AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.TRANSITION_AND__LEFT));
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.TRANSITION_AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.TRANSITION_AND__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTransitionAndAccess().getTransitionAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getTransitionAndAccess().getRightTransitionOrParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=TransitionOr_TransitionOr_1_0 right=ITransition)
	 */
	protected void sequence_TransitionOr(EObject context, TransitionOr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.TRANSITION_OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.TRANSITION_OR__LEFT));
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.TRANSITION_OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.TRANSITION_OR__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTransitionOrAccess().getTransitionOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getTransitionOrAccess().getRightITransitionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_VariableAttribute(EObject context, VariableAttribute semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.VARIABLE_ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.VARIABLE_ATTRIBUTE__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getVariableAttributeAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (type=Type name=ID (attributes+=Attribute attributes+=Attribute*)?)
	 */
	protected void sequence_VariableDeclaration(EObject context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
