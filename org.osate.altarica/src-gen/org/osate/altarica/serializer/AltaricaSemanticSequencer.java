/*
 * generated by Xtext
 */
package org.osate.altarica.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.osate.altarica.altarica.ARBoolean;
import org.osate.altarica.altarica.ARInteger;
import org.osate.altarica.altarica.ARString;
import org.osate.altarica.altarica.Addition;
import org.osate.altarica.altarica.AltaricaPackage;
import org.osate.altarica.altarica.And;
import org.osate.altarica.altarica.Assert;
import org.osate.altarica.altarica.AssertSpecification;
import org.osate.altarica.altarica.Assignment;
import org.osate.altarica.altarica.Cardinality;
import org.osate.altarica.altarica.CaseExpression;
import org.osate.altarica.altarica.ConstantDefinition;
import org.osate.altarica.altarica.Division;
import org.osate.altarica.altarica.Domain;
import org.osate.altarica.altarica.DomainConstant;
import org.osate.altarica.altarica.DomainRef;
import org.osate.altarica.altarica.Enumeration;
import org.osate.altarica.altarica.EnumerationLiteral;
import org.osate.altarica.altarica.Equal;
import org.osate.altarica.altarica.Event;
import org.osate.altarica.altarica.EventRef;
import org.osate.altarica.altarica.EventSpecification;
import org.osate.altarica.altarica.Expression;
import org.osate.altarica.altarica.ExpressionConstant;
import org.osate.altarica.altarica.ExternalDirective;
import org.osate.altarica.altarica.ExternalSpecification;
import org.osate.altarica.altarica.Flow;
import org.osate.altarica.altarica.FlowSpecification;
import org.osate.altarica.altarica.IfThenElse;
import org.osate.altarica.altarica.Imply;
import org.osate.altarica.altarica.InitSpecification;
import org.osate.altarica.altarica.InitStatement;
import org.osate.altarica.altarica.Lower;
import org.osate.altarica.altarica.Minus;
import org.osate.altarica.altarica.Multiplication;
import org.osate.altarica.altarica.NestedQualifiedEventRef;
import org.osate.altarica.altarica.NestedQualifiedVariableRef;
import org.osate.altarica.altarica.Node;
import org.osate.altarica.altarica.NodeInstance;
import org.osate.altarica.altarica.NodeInstanceSpecification;
import org.osate.altarica.altarica.NotEqual;
import org.osate.altarica.altarica.Or;
import org.osate.altarica.altarica.PrimitiveType;
import org.osate.altarica.altarica.Priority;
import org.osate.altarica.altarica.Range;
import org.osate.altarica.altarica.State;
import org.osate.altarica.altarica.StateSpecification;
import org.osate.altarica.altarica.StrictLower;
import org.osate.altarica.altarica.StrictUpper;
import org.osate.altarica.altarica.Switch;
import org.osate.altarica.altarica.Transition;
import org.osate.altarica.altarica.TransitionSpecification;
import org.osate.altarica.altarica.Upper;
import org.osate.altarica.altarica.VariableAttribute;
import org.osate.altarica.altarica.VariableRef;
import org.osate.altarica.altarica.Vector;
import org.osate.altarica.altarica.VectorParameter;
import org.osate.altarica.altarica.VectorSpecification;
import org.osate.altarica.services.AltaricaGrammarAccess;

@SuppressWarnings("all")
public class AltaricaSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AltaricaGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == AltaricaPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case AltaricaPackage.AR_BOOLEAN:
				sequence_BooleanLiteral(context, (ARBoolean) semanticObject); 
				return; 
			case AltaricaPackage.AR_INTEGER:
				sequence_IntegerLiteral(context, (ARInteger) semanticObject); 
				return; 
			case AltaricaPackage.AR_STRING:
				sequence_StringLiteral(context, (ARString) semanticObject); 
				return; 
			case AltaricaPackage.ADDITION:
				sequence_Expression(context, (Addition) semanticObject); 
				return; 
			case AltaricaPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case AltaricaPackage.ASSERT:
				sequence_Assert(context, (Assert) semanticObject); 
				return; 
			case AltaricaPackage.ASSERT_SPECIFICATION:
				sequence_AssertSpecification(context, (AssertSpecification) semanticObject); 
				return; 
			case AltaricaPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case AltaricaPackage.CARDINALITY:
				sequence_Cardinality(context, (Cardinality) semanticObject); 
				return; 
			case AltaricaPackage.CASE_EXPRESSION:
				sequence_CaseExpression(context, (CaseExpression) semanticObject); 
				return; 
			case AltaricaPackage.CONSTANT_DEFINITION:
				sequence_ConstantDefinition(context, (ConstantDefinition) semanticObject); 
				return; 
			case AltaricaPackage.DIVISION:
				sequence_Division(context, (Division) semanticObject); 
				return; 
			case AltaricaPackage.DOMAIN:
				sequence_Domain(context, (Domain) semanticObject); 
				return; 
			case AltaricaPackage.DOMAIN_CONSTANT:
				sequence_DomainConstant(context, (DomainConstant) semanticObject); 
				return; 
			case AltaricaPackage.DOMAIN_REF:
				sequence_DomainRef(context, (DomainRef) semanticObject); 
				return; 
			case AltaricaPackage.ENUMERATION:
				sequence_Enumeration(context, (Enumeration) semanticObject); 
				return; 
			case AltaricaPackage.ENUMERATION_LITERAL:
				sequence_Literal(context, (EnumerationLiteral) semanticObject); 
				return; 
			case AltaricaPackage.EQUAL:
				sequence_Equal(context, (Equal) semanticObject); 
				return; 
			case AltaricaPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case AltaricaPackage.EVENT_REF:
				sequence_EventRef(context, (EventRef) semanticObject); 
				return; 
			case AltaricaPackage.EVENT_SPECIFICATION:
				sequence_EventSpecification(context, (EventSpecification) semanticObject); 
				return; 
			case AltaricaPackage.EXPRESSION:
				sequence_Not(context, (Expression) semanticObject); 
				return; 
			case AltaricaPackage.EXPRESSION_CONSTANT:
				sequence_ExpressionConstant(context, (ExpressionConstant) semanticObject); 
				return; 
			case AltaricaPackage.EXTERNAL_DIRECTIVE:
				sequence_ExternalDirective(context, (ExternalDirective) semanticObject); 
				return; 
			case AltaricaPackage.EXTERNAL_SPECIFICATION:
				sequence_ExternalSpecification(context, (ExternalSpecification) semanticObject); 
				return; 
			case AltaricaPackage.FLOW:
				sequence_Flow(context, (Flow) semanticObject); 
				return; 
			case AltaricaPackage.FLOW_SPECIFICATION:
				sequence_FlowSpecification(context, (FlowSpecification) semanticObject); 
				return; 
			case AltaricaPackage.IF_THEN_ELSE:
				sequence_IfThenElse(context, (IfThenElse) semanticObject); 
				return; 
			case AltaricaPackage.IMPLY:
				sequence_Imply(context, (Imply) semanticObject); 
				return; 
			case AltaricaPackage.INIT_SPECIFICATION:
				sequence_InitSpecification(context, (InitSpecification) semanticObject); 
				return; 
			case AltaricaPackage.INIT_STATEMENT:
				sequence_InitStatement(context, (InitStatement) semanticObject); 
				return; 
			case AltaricaPackage.LOWER:
				sequence_Lower(context, (Lower) semanticObject); 
				return; 
			case AltaricaPackage.MINUS:
				sequence_Minus(context, (Minus) semanticObject); 
				return; 
			case AltaricaPackage.MULTIPLICATION:
				sequence_Multiplication(context, (Multiplication) semanticObject); 
				return; 
			case AltaricaPackage.NESTED_QUALIFIED_EVENT_REF:
				sequence_EventRef(context, (NestedQualifiedEventRef) semanticObject); 
				return; 
			case AltaricaPackage.NESTED_QUALIFIED_VARIABLE_REF:
				sequence_VariableRef(context, (NestedQualifiedVariableRef) semanticObject); 
				return; 
			case AltaricaPackage.NODE:
				sequence_Node(context, (Node) semanticObject); 
				return; 
			case AltaricaPackage.NODE_INSTANCE:
				sequence_NodeInstance(context, (NodeInstance) semanticObject); 
				return; 
			case AltaricaPackage.NODE_INSTANCE_SPECIFICATION:
				sequence_NodeInstanceSpecification(context, (NodeInstanceSpecification) semanticObject); 
				return; 
			case AltaricaPackage.NOT_EQUAL:
				sequence_NotEqual(context, (NotEqual) semanticObject); 
				return; 
			case AltaricaPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case AltaricaPackage.PRIMITIVE_TYPE:
				sequence_PrimitiveType(context, (PrimitiveType) semanticObject); 
				return; 
			case AltaricaPackage.PRIORITY:
				sequence_Priority(context, (Priority) semanticObject); 
				return; 
			case AltaricaPackage.RANGE:
				sequence_Range(context, (Range) semanticObject); 
				return; 
			case AltaricaPackage.STATE:
				sequence_State(context, (State) semanticObject); 
				return; 
			case AltaricaPackage.STATE_SPECIFICATION:
				sequence_StateSpecification(context, (StateSpecification) semanticObject); 
				return; 
			case AltaricaPackage.STRICT_LOWER:
				sequence_StrictLower(context, (StrictLower) semanticObject); 
				return; 
			case AltaricaPackage.STRICT_UPPER:
				sequence_StrictUpper(context, (StrictUpper) semanticObject); 
				return; 
			case AltaricaPackage.SWITCH:
				sequence_Switch(context, (Switch) semanticObject); 
				return; 
			case AltaricaPackage.SYSTEM:
				sequence_System(context, (org.osate.altarica.altarica.System) semanticObject); 
				return; 
			case AltaricaPackage.TRANSITION:
				sequence_Transition(context, (Transition) semanticObject); 
				return; 
			case AltaricaPackage.TRANSITION_SPECIFICATION:
				sequence_TransitionSpecification(context, (TransitionSpecification) semanticObject); 
				return; 
			case AltaricaPackage.UPPER:
				sequence_Upper(context, (Upper) semanticObject); 
				return; 
			case AltaricaPackage.VARIABLE_ATTRIBUTE:
				sequence_VariableAttribute(context, (VariableAttribute) semanticObject); 
				return; 
			case AltaricaPackage.VARIABLE_REF:
				sequence_VariableRef(context, (VariableRef) semanticObject); 
				return; 
			case AltaricaPackage.VECTOR:
				sequence_Vector(context, (Vector) semanticObject); 
				return; 
			case AltaricaPackage.VECTOR_PARAMETER:
				sequence_VectorParameter(context, (VectorParameter) semanticObject); 
				return; 
			case AltaricaPackage.VECTOR_SPECIFICATION:
				sequence_VectorSpecification(context, (VectorSpecification) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (leftOperand=And_And_1_0 rightOperand=Or)
	 */
	protected void sequence_And(EObject context, And semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ownedAsserts+=Assert+
	 */
	protected void sequence_AssertSpecification(EObject context, AssertSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ownedExpressions+=AbstractBooleanExpression
	 */
	protected void sequence_Assert(EObject context, Assert semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (state=[State|ID] ownedExpression=AbstractExpression)
	 */
	protected void sequence_Assignment(EObject context, Assignment semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.ASSIGNMENT__STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.ASSIGNMENT__STATE));
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.ASSIGNMENT__OWNED_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.ASSIGNMENT__OWNED_EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAssignmentAccess().getStateStateIDTerminalRuleCall_0_0_1(), semanticObject.getState());
		feeder.accept(grammarAccess.getAssignmentAccess().getOwnedExpressionAbstractExpressionParserRuleCall_2_0(), semanticObject.getOwnedExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_BooleanLiteral(EObject context, ARBoolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expression=AbstractExpression | expression=AbstractExpression | expression=AbstractExpression)
	 */
	protected void sequence_Cardinality(EObject context, Cardinality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (condition=BooleanExpression body=Expression)
	 */
	protected void sequence_CaseExpression(EObject context, CaseExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.CASE_EXPRESSION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.CASE_EXPRESSION__CONDITION));
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.CASE_EXPRESSION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.CASE_EXPRESSION__BODY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCaseExpressionAccess().getConditionBooleanExpressionParserRuleCall_0_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getCaseExpressionAccess().getBodyExpressionParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID expression=AbstractDefinitionConstant)
	 */
	protected void sequence_ConstantDefinition(EObject context, ConstantDefinition semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.NAMED_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.CONSTANT_DEFINITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.CONSTANT_DEFINITION__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getConstantDefinitionAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getConstantDefinitionAccess().getExpressionAbstractDefinitionConstantParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=Division_Division_1_0 rightOperand=BooleanExpression)
	 */
	protected void sequence_Division(EObject context, Division semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (domain=AbstractDomain ownedExpression=Expression?)
	 */
	protected void sequence_DomainConstant(EObject context, DomainConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     reference=[Domain|ID]
	 */
	protected void sequence_DomainRef(EObject context, DomainRef semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.DOMAIN_REF__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.DOMAIN_REF__REFERENCE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDomainRefAccess().getReferenceDomainIDTerminalRuleCall_0_1(), semanticObject.getReference());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID domain=AbstractDomain)
	 */
	protected void sequence_Domain(EObject context, Domain semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.NAMED_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.DOMAIN__DOMAIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.DOMAIN__DOMAIN));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDomainAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDomainAccess().getDomainAbstractDomainParserRuleCall_4_0(), semanticObject.getDomain());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (ownedLiterals+=Literal ownedLiterals+=Literal*)
	 */
	protected void sequence_Enumeration(EObject context, Enumeration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=Equal_Equal_1_0 rightOperand=NotEqual)
	 */
	protected void sequence_Equal(EObject context, Equal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     variable=[NamedElement|ID]
	 */
	protected void sequence_EventRef(EObject context, EventRef semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.EVENT_REF__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.EVENT_REF__VARIABLE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEventRefAccess().getVariableNamedElementIDTerminalRuleCall_0_0_1(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (target=EventRef_NestedQualifiedEventRef_1_0 nestedVariable=[NamedElement|ID])
	 */
	protected void sequence_EventRef(EObject context, NestedQualifiedEventRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ownedEvents+=Event+
	 */
	protected void sequence_EventSpecification(EObject context, EventSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID ownedPriority=Priority? attribute=VariableAttribute?)
	 */
	protected void sequence_Event(EObject context, Event semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ownedExpression=Expression
	 */
	protected void sequence_ExpressionConstant(EObject context, ExpressionConstant semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.ABSTRACT_DEFINITION_CONSTANT__OWNED_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.ABSTRACT_DEFINITION_CONSTANT__OWNED_EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExpressionConstantAccess().getOwnedExpressionExpressionParserRuleCall_1_0(), semanticObject.getOwnedExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=Expression_Addition_1_0 rightOperand=Minus)
	 */
	protected void sequence_Expression(EObject context, Addition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     directive=SL_COMMENT
	 */
	protected void sequence_ExternalDirective(EObject context, ExternalDirective semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.EXTERNAL_DIRECTIVE__DIRECTIVE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.EXTERNAL_DIRECTIVE__DIRECTIVE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExternalDirectiveAccess().getDirectiveSL_COMMENTTerminalRuleCall_0(), semanticObject.getDirective());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ownedDirectives+=ExternalDirective+
	 */
	protected void sequence_ExternalSpecification(EObject context, ExternalSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ownedFlows+=Flow+
	 */
	protected void sequence_FlowSpecification(EObject context, FlowSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID domain=AbstractTypeRef kind=FlowKind? attribute=VariableAttribute?)
	 */
	protected void sequence_Flow(EObject context, Flow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (condition=BooleanExpression (then=Switch | then=Expression) (else=Switch | else=Expression))
	 */
	protected void sequence_IfThenElse(EObject context, IfThenElse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=Imply_Imply_1_0 rightOperand=Not)
	 */
	protected void sequence_Imply(EObject context, Imply semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ownedInitStatements+=InitStatement+
	 */
	protected void sequence_InitSpecification(EObject context, InitSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     affectation=Assignment
	 */
	protected void sequence_InitStatement(EObject context, InitStatement semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.INIT_STATEMENT__AFFECTATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.INIT_STATEMENT__AFFECTATION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInitStatementAccess().getAffectationAssignmentParserRuleCall_0_0(), semanticObject.getAffectation());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_IntegerLiteral(EObject context, ARInteger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Literal(EObject context, EnumerationLiteral semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.NAMED_ELEMENT__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getLiteralAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=Lower_Lower_1_0 rightOperand=StrictUpper)
	 */
	protected void sequence_Lower(EObject context, Lower semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=Minus_Minus_1_0 rightOperand=Multiplication)
	 */
	protected void sequence_Minus(EObject context, Minus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=Multiplication_Multiplication_1_0 rightOperand=Division)
	 */
	protected void sequence_Multiplication(EObject context, Multiplication semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ownedNodeInstances+=NodeInstance+
	 */
	protected void sequence_NodeInstanceSpecification(EObject context, NodeInstanceSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID nodeType=[Node|ID])
	 */
	protected void sequence_NodeInstance(EObject context, NodeInstance semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.NAMED_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.NODE_INSTANCE__NODE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.NODE_INSTANCE__NODE_TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNodeInstanceAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNodeInstanceAccess().getNodeTypeNodeIDTerminalRuleCall_3_0_1(), semanticObject.getNodeType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID ownedSpecifications+=AbstractSpecification*)
	 */
	protected void sequence_Node(EObject context, Node semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=NotEqual_NotEqual_1_0 rightOperand=StrictLower)
	 */
	protected void sequence_NotEqual(EObject context, NotEqual semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     operand=Atom
	 */
	protected void sequence_Not(EObject context, Expression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.EXPRESSION__OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNotAccess().getOperandAtomParserRuleCall_0_1_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=Or_Or_1_0 rightOperand=Equal)
	 */
	protected void sequence_Or(EObject context, Or semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=PrimitiveTypeKind
	 */
	protected void sequence_PrimitiveType(EObject context, PrimitiveType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.PRIMITIVE_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.PRIMITIVE_TYPE__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPrimitiveTypeAccess().getNamePrimitiveTypeKindEnumRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ownedExpression=AbstractExpression
	 */
	protected void sequence_Priority(EObject context, Priority semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.PRIORITY__OWNED_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.PRIORITY__OWNED_EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPriorityAccess().getOwnedExpressionAbstractExpressionParserRuleCall_1_0(), semanticObject.getOwnedExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (lower=Atom upper=Atom)
	 */
	protected void sequence_Range(EObject context, Range semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.RANGE__LOWER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.RANGE__LOWER));
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.RANGE__UPPER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.RANGE__UPPER));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRangeAccess().getLowerAtomParserRuleCall_1_0(), semanticObject.getLower());
		feeder.accept(grammarAccess.getRangeAccess().getUpperAtomParserRuleCall_3_0(), semanticObject.getUpper());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ownedStates+=State+
	 */
	protected void sequence_StateSpecification(EObject context, StateSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID domain=AbstractTypeRef attribute=VariableAttribute?)
	 */
	protected void sequence_State(EObject context, State semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=StrictLower_StrictLower_1_0 rightOperand=Lower)
	 */
	protected void sequence_StrictLower(EObject context, StrictLower semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=StrictUpper_StrictUpper_1_0 rightOperand=Upper)
	 */
	protected void sequence_StrictUpper(EObject context, StrictUpper semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteral(EObject context, ARString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (ownedCases+=CaseExpression* default=Expression)
	 */
	protected void sequence_Switch(EObject context, Switch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ownedDeclarations+=AbstractDeclaration*
	 */
	protected void sequence_System(EObject context, org.osate.altarica.altarica.System semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ownedTransitionTransitions+=Transition+
	 */
	protected void sequence_TransitionSpecification(EObject context, TransitionSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (ownedExpression=AbstractExpression event=[Event|ID] (ownedAffectations+=Assignment ownedAffectations+=Assignment*)*)
	 */
	protected void sequence_Transition(EObject context, Transition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftOperand=Upper_Upper_1_0 rightOperand=Imply)
	 */
	protected void sequence_Upper(EObject context, Upper semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_VariableAttribute(EObject context, VariableAttribute semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, AltaricaPackage.Literals.VARIABLE_ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AltaricaPackage.Literals.VARIABLE_ATTRIBUTE__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getVariableAttributeAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (target=VariableRef_NestedQualifiedVariableRef_1_0 nestedVariable=[NamedElement|ID])
	 */
	protected void sequence_VariableRef(EObject context, NestedQualifiedVariableRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     variable=[NamedElement|ID]
	 */
	protected void sequence_VariableRef(EObject context, VariableRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (eventParameter=EventRef isRequired?='?'?)
	 */
	protected void sequence_VectorParameter(EObject context, VectorParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ownedVectors+=Vector+
	 */
	protected void sequence_VectorSpecification(EObject context, VectorSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (ownedParameters+=VectorParameter ownedParameters+=VectorParameter* cardinality=Cardinality?)
	 */
	protected void sequence_Vector(EObject context, Vector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
