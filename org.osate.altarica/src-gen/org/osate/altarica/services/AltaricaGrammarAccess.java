/*
 * generated by Xtext
 */
package org.osate.altarica.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class AltaricaGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Model");
		private final Assignment cDeclarationsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cDeclarationsAbstractDeclarationParserRuleCall_0 = (RuleCall)cDeclarationsAssignment.eContents().get(0);
		
		//Model:
		//	declarations+=AbstractDeclaration*;
		@Override public ParserRule getRule() { return rule; }

		//declarations+=AbstractDeclaration*
		public Assignment getDeclarationsAssignment() { return cDeclarationsAssignment; }

		//AbstractDeclaration
		public RuleCall getDeclarationsAbstractDeclarationParserRuleCall_0() { return cDeclarationsAbstractDeclarationParserRuleCall_0; }
	}

	public class AbstractDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AbstractDeclaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDomainParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cClassParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//AbstractDeclaration:
		//	Domain | Class;
		@Override public ParserRule getRule() { return rule; }

		//Domain | Class
		public Alternatives getAlternatives() { return cAlternatives; }

		//Domain
		public RuleCall getDomainParserRuleCall_0() { return cDomainParserRuleCall_0; }

		//Class
		public RuleCall getClassParserRuleCall_1() { return cClassParserRuleCall_1; }
	}

	public class DomainElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Domain");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDomainAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cDomainKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cConstantsAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cConstantsSymbolicConstantParserRuleCall_4_0_0 = (RuleCall)cConstantsAssignment_4_0.eContents().get(0);
		private final Group cGroup_4_1 = (Group)cGroup_4.eContents().get(1);
		private final Keyword cCommaKeyword_4_1_0 = (Keyword)cGroup_4_1.eContents().get(0);
		private final Assignment cConstantsAssignment_4_1_1 = (Assignment)cGroup_4_1.eContents().get(1);
		private final RuleCall cConstantsSymbolicConstantParserRuleCall_4_1_1_0 = (RuleCall)cConstantsAssignment_4_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Domain returns NamedElement:
		//	{Domain} "domain" name=ID "{" (constants+=SymbolicConstant ("," constants+=SymbolicConstant)*)? "}";
		@Override public ParserRule getRule() { return rule; }

		//{Domain} "domain" name=ID "{" (constants+=SymbolicConstant ("," constants+=SymbolicConstant)*)? "}"
		public Group getGroup() { return cGroup; }

		//{Domain}
		public Action getDomainAction_0() { return cDomainAction_0; }

		//"domain"
		public Keyword getDomainKeyword_1() { return cDomainKeyword_1; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }

		//(constants+=SymbolicConstant ("," constants+=SymbolicConstant)*)?
		public Group getGroup_4() { return cGroup_4; }

		//constants+=SymbolicConstant
		public Assignment getConstantsAssignment_4_0() { return cConstantsAssignment_4_0; }

		//SymbolicConstant
		public RuleCall getConstantsSymbolicConstantParserRuleCall_4_0_0() { return cConstantsSymbolicConstantParserRuleCall_4_0_0; }

		//("," constants+=SymbolicConstant)*
		public Group getGroup_4_1() { return cGroup_4_1; }

		//","
		public Keyword getCommaKeyword_4_1_0() { return cCommaKeyword_4_1_0; }

		//constants+=SymbolicConstant
		public Assignment getConstantsAssignment_4_1_1() { return cConstantsAssignment_4_1_1; }

		//SymbolicConstant
		public RuleCall getConstantsSymbolicConstantParserRuleCall_4_1_1_0() { return cConstantsSymbolicConstantParserRuleCall_4_1_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}

	public class SymbolicConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SymbolicConstant");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSymbolicConstantAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//SymbolicConstant returns NamedElement:
		//	{SymbolicConstant} name=ID;
		@Override public ParserRule getRule() { return rule; }

		//{SymbolicConstant} name=ID
		public Group getGroup() { return cGroup; }

		//{SymbolicConstant}
		public Action getSymbolicConstantAction_0() { return cSymbolicConstantAction_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}

	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBaseTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNamedTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Type:
		//	BaseType | NamedType;
		@Override public ParserRule getRule() { return rule; }

		//=> BaseType | NamedType
		public Alternatives getAlternatives() { return cAlternatives; }

		//=> BaseType
		public RuleCall getBaseTypeParserRuleCall_0() { return cBaseTypeParserRuleCall_0; }

		//NamedType
		public RuleCall getNamedTypeParserRuleCall_1() { return cNamedTypeParserRuleCall_1; }
	}

	public class BaseTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BaseType");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameBaseTypeEnumEnumRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//BaseType:
		//	name=BaseTypeEnum;
		@Override public ParserRule getRule() { return rule; }

		//name=BaseTypeEnum
		public Assignment getNameAssignment() { return cNameAssignment; }

		//BaseTypeEnum
		public RuleCall getNameBaseTypeEnumEnumRuleCall_0() { return cNameBaseTypeEnumEnumRuleCall_0; }
	}

	public class NamedTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NamedType");
		private final Assignment cRefAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cRefNamedElementCrossReference_0 = (CrossReference)cRefAssignment.eContents().get(0);
		private final RuleCall cRefNamedElementIDTerminalRuleCall_0_1 = (RuleCall)cRefNamedElementCrossReference_0.eContents().get(1);
		
		//NamedType:
		//	ref=[NamedElement];
		@Override public ParserRule getRule() { return rule; }

		//ref=[NamedElement]
		public Assignment getRefAssignment() { return cRefAssignment; }

		//[NamedElement]
		public CrossReference getRefNamedElementCrossReference_0() { return cRefNamedElementCrossReference_0; }

		//ID
		public RuleCall getRefNamedElementIDTerminalRuleCall_0_1() { return cRefNamedElementIDTerminalRuleCall_0_1; }
	}

	public class ClassElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Class");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNodeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cClassKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Assignment cDeclarationsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cDeclarationsDeclarationParserRuleCall_3_0 = (RuleCall)cDeclarationsAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cTransitionKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cTransitionsAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cTransitionsLabeledTransitionParserRuleCall_4_1_0 = (RuleCall)cTransitionsAssignment_4_1.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cAssertionKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cAssertionsAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cAssertionsInstructionParserRuleCall_5_1_0 = (RuleCall)cAssertionsAssignment_5_1.eContents().get(0);
		private final Keyword cEndKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//// ========== Classes ==========
		//Class returns NamedElement:
		//	{Node} "class" name=ID declarations+=Declaration* ("transition" transitions+=LabeledTransition+)? ("assertion"
		//	assertions+=Instruction+)? "end";
		@Override public ParserRule getRule() { return rule; }

		//{Node} "class" name=ID declarations+=Declaration* ("transition" transitions+=LabeledTransition+)? ("assertion"
		//assertions+=Instruction+)? "end"
		public Group getGroup() { return cGroup; }

		//{Node}
		public Action getNodeAction_0() { return cNodeAction_0; }

		//"class"
		public Keyword getClassKeyword_1() { return cClassKeyword_1; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//declarations+=Declaration*
		public Assignment getDeclarationsAssignment_3() { return cDeclarationsAssignment_3; }

		//Declaration
		public RuleCall getDeclarationsDeclarationParserRuleCall_3_0() { return cDeclarationsDeclarationParserRuleCall_3_0; }

		//("transition" transitions+=LabeledTransition+)?
		public Group getGroup_4() { return cGroup_4; }

		//"transition"
		public Keyword getTransitionKeyword_4_0() { return cTransitionKeyword_4_0; }

		//transitions+=LabeledTransition+
		public Assignment getTransitionsAssignment_4_1() { return cTransitionsAssignment_4_1; }

		//LabeledTransition
		public RuleCall getTransitionsLabeledTransitionParserRuleCall_4_1_0() { return cTransitionsLabeledTransitionParserRuleCall_4_1_0; }

		//("assertion" assertions+=Instruction+)?
		public Group getGroup_5() { return cGroup_5; }

		//"assertion"
		public Keyword getAssertionKeyword_5_0() { return cAssertionKeyword_5_0; }

		//assertions+=Instruction+
		public Assignment getAssertionsAssignment_5_1() { return cAssertionsAssignment_5_1; }

		//Instruction
		public RuleCall getAssertionsInstructionParserRuleCall_5_1_0() { return cAssertionsInstructionParserRuleCall_5_1_0; }

		//"end"
		public Keyword getEndKeyword_6() { return cEndKeyword_6; }
	}

	public class DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Declaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVariableDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEventDeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cParameterDeclarationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cObserverDeclarationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//// ========== Declarations ==========
		//Declaration:
		//	VariableDeclaration | EventDeclaration | ParameterDeclaration | ObserverDeclaration;
		@Override public ParserRule getRule() { return rule; }

		//VariableDeclaration | EventDeclaration | ParameterDeclaration | ObserverDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }

		//VariableDeclaration
		public RuleCall getVariableDeclarationParserRuleCall_0() { return cVariableDeclarationParserRuleCall_0; }

		//EventDeclaration
		public RuleCall getEventDeclarationParserRuleCall_1() { return cEventDeclarationParserRuleCall_1; }

		//ParameterDeclaration
		public RuleCall getParameterDeclarationParserRuleCall_2() { return cParameterDeclarationParserRuleCall_2; }

		//ObserverDeclaration
		public RuleCall getObserverDeclarationParserRuleCall_3() { return cObserverDeclarationParserRuleCall_3; }
	}

	public class VariableDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVariableAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeTypeParserRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cAttributesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cAttributesAttributeParserRuleCall_3_1_0 = (RuleCall)cAttributesAssignment_3_1.eContents().get(0);
		private final Group cGroup_3_2 = (Group)cGroup_3.eContents().get(2);
		private final Keyword cCommaKeyword_3_2_0 = (Keyword)cGroup_3_2.eContents().get(0);
		private final Assignment cAttributesAssignment_3_2_1 = (Assignment)cGroup_3_2.eContents().get(1);
		private final RuleCall cAttributesAttributeParserRuleCall_3_2_1_0 = (RuleCall)cAttributesAssignment_3_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3_3 = (Keyword)cGroup_3.eContents().get(3);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//VariableDeclaration returns NamedElement:
		//	{Variable} type=Type name=ID ("(" attributes+=Attribute ("," attributes+=Attribute)* ")")? ";";
		@Override public ParserRule getRule() { return rule; }

		//{Variable} type=Type name=ID ("(" attributes+=Attribute ("," attributes+=Attribute)* ")")? ";"
		public Group getGroup() { return cGroup; }

		//{Variable}
		public Action getVariableAction_0() { return cVariableAction_0; }

		//type=Type
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_1_0() { return cTypeTypeParserRuleCall_1_0; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//("(" attributes+=Attribute ("," attributes+=Attribute)* ")")?
		public Group getGroup_3() { return cGroup_3; }

		//"("
		public Keyword getLeftParenthesisKeyword_3_0() { return cLeftParenthesisKeyword_3_0; }

		//attributes+=Attribute
		public Assignment getAttributesAssignment_3_1() { return cAttributesAssignment_3_1; }

		//Attribute
		public RuleCall getAttributesAttributeParserRuleCall_3_1_0() { return cAttributesAttributeParserRuleCall_3_1_0; }

		//("," attributes+=Attribute)*
		public Group getGroup_3_2() { return cGroup_3_2; }

		//","
		public Keyword getCommaKeyword_3_2_0() { return cCommaKeyword_3_2_0; }

		//attributes+=Attribute
		public Assignment getAttributesAssignment_3_2_1() { return cAttributesAssignment_3_2_1; }

		//Attribute
		public RuleCall getAttributesAttributeParserRuleCall_3_2_1_0() { return cAttributesAttributeParserRuleCall_3_2_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3_3() { return cRightParenthesisKeyword_3_3; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class AttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Attribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAttributeAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueExpressionParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		
		//Attribute returns NamedElement:
		//	{Attribute} name=ID "=" value=Expression;
		@Override public ParserRule getRule() { return rule; }

		//{Attribute} name=ID "=" value=Expression
		public Group getGroup() { return cGroup; }

		//{Attribute}
		public Action getAttributeAction_0() { return cAttributeAction_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//value=Expression
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_3_0() { return cValueExpressionParserRuleCall_3_0; }
	}

	public class EventDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EventDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cEventAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cEventKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cAttributesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cAttributesAttributeParserRuleCall_3_1_0 = (RuleCall)cAttributesAssignment_3_1.eContents().get(0);
		private final Group cGroup_3_2 = (Group)cGroup_3.eContents().get(2);
		private final Keyword cCommaKeyword_3_2_0 = (Keyword)cGroup_3_2.eContents().get(0);
		private final Assignment cAttributesAssignment_3_2_1 = (Assignment)cGroup_3_2.eContents().get(1);
		private final RuleCall cAttributesAttributeParserRuleCall_3_2_1_0 = (RuleCall)cAttributesAssignment_3_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3_3 = (Keyword)cGroup_3.eContents().get(3);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//EventDeclaration returns NamedElement:
		//	{Event} "event" name=ID ("(" attributes+=Attribute ("," attributes+=Attribute)* ")")? ";";
		@Override public ParserRule getRule() { return rule; }

		//{Event} "event" name=ID ("(" attributes+=Attribute ("," attributes+=Attribute)* ")")? ";"
		public Group getGroup() { return cGroup; }

		//{Event}
		public Action getEventAction_0() { return cEventAction_0; }

		//"event"
		public Keyword getEventKeyword_1() { return cEventKeyword_1; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//("(" attributes+=Attribute ("," attributes+=Attribute)* ")")?
		public Group getGroup_3() { return cGroup_3; }

		//"("
		public Keyword getLeftParenthesisKeyword_3_0() { return cLeftParenthesisKeyword_3_0; }

		//attributes+=Attribute
		public Assignment getAttributesAssignment_3_1() { return cAttributesAssignment_3_1; }

		//Attribute
		public RuleCall getAttributesAttributeParserRuleCall_3_1_0() { return cAttributesAttributeParserRuleCall_3_1_0; }

		//("," attributes+=Attribute)*
		public Group getGroup_3_2() { return cGroup_3_2; }

		//","
		public Keyword getCommaKeyword_3_2_0() { return cCommaKeyword_3_2_0; }

		//attributes+=Attribute
		public Assignment getAttributesAssignment_3_2_1() { return cAttributesAssignment_3_2_1; }

		//Attribute
		public RuleCall getAttributesAttributeParserRuleCall_3_2_1_0() { return cAttributesAttributeParserRuleCall_3_2_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3_3() { return cRightParenthesisKeyword_3_3; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class ParameterDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParameterDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cParameterAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cParameterKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Keyword cEqualsSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cValueAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cValueExpressionParserRuleCall_5_0 = (RuleCall)cValueAssignment_5.eContents().get(0);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//ParameterDeclaration returns NamedElement:
		//	{Parameter} "parameter" type=Type name=ID "=" value=Expression ";";
		@Override public ParserRule getRule() { return rule; }

		//{Parameter} "parameter" type=Type name=ID "=" value=Expression ";"
		public Group getGroup() { return cGroup; }

		//{Parameter}
		public Action getParameterAction_0() { return cParameterAction_0; }

		//"parameter"
		public Keyword getParameterKeyword_1() { return cParameterKeyword_1; }

		//type=Type
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_2_0() { return cTypeTypeParserRuleCall_2_0; }

		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }

		//"="
		public Keyword getEqualsSignKeyword_4() { return cEqualsSignKeyword_4; }

		//value=Expression
		public Assignment getValueAssignment_5() { return cValueAssignment_5; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_5_0() { return cValueExpressionParserRuleCall_5_0; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class ObserverDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ObserverDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cObserverAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cObserverKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Keyword cEqualsSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cValueAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cValueExpressionParserRuleCall_5_0 = (RuleCall)cValueAssignment_5.eContents().get(0);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//ObserverDeclaration returns NamedElement:
		//	{Observer} "observer" type=Type name=ID "=" value=Expression ";";
		@Override public ParserRule getRule() { return rule; }

		//{Observer} "observer" type=Type name=ID "=" value=Expression ";"
		public Group getGroup() { return cGroup; }

		//{Observer}
		public Action getObserverAction_0() { return cObserverAction_0; }

		//"observer"
		public Keyword getObserverKeyword_1() { return cObserverKeyword_1; }

		//type=Type
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_2_0() { return cTypeTypeParserRuleCall_2_0; }

		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }

		//"="
		public Keyword getEqualsSignKeyword_4() { return cEqualsSignKeyword_4; }

		//value=Expression
		public Assignment getValueAssignment_5() { return cValueAssignment_5; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_5_0() { return cValueExpressionParserRuleCall_5_0; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class LabeledTransitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LabeledTransition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cEventAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cEventNameRefParserRuleCall_0_0 = (RuleCall)cEventAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionTransitionAndParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		
		//// ========== Transitions ==========
		//LabeledTransition:
		//	event=NameRef ":" expression=TransitionAnd;
		@Override public ParserRule getRule() { return rule; }

		//event=NameRef ":" expression=TransitionAnd
		public Group getGroup() { return cGroup; }

		//event=NameRef
		public Assignment getEventAssignment_0() { return cEventAssignment_0; }

		//NameRef
		public RuleCall getEventNameRefParserRuleCall_0_0() { return cEventNameRefParserRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//expression=TransitionAnd
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }

		//TransitionAnd
		public RuleCall getExpressionTransitionAndParserRuleCall_2_0() { return cExpressionTransitionAndParserRuleCall_2_0; }
	}

	public class TransitionAndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TransitionAnd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTransitionOrParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cTransitionAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAmpersandKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightTransitionOrParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//TransitionAnd returns TransitionExpression:
		//	TransitionOr ({TransitionAnd.left=current} "&" right=TransitionOr)*;
		@Override public ParserRule getRule() { return rule; }

		//TransitionOr ({TransitionAnd.left=current} "&" right=TransitionOr)*
		public Group getGroup() { return cGroup; }

		//TransitionOr
		public RuleCall getTransitionOrParserRuleCall_0() { return cTransitionOrParserRuleCall_0; }

		//({TransitionAnd.left=current} "&" right=TransitionOr)*
		public Group getGroup_1() { return cGroup_1; }

		//{TransitionAnd.left=current}
		public Action getTransitionAndLeftAction_1_0() { return cTransitionAndLeftAction_1_0; }

		//"&"
		public Keyword getAmpersandKeyword_1_1() { return cAmpersandKeyword_1_1; }

		//right=TransitionOr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//TransitionOr
		public RuleCall getRightTransitionOrParserRuleCall_1_2_0() { return cRightTransitionOrParserRuleCall_1_2_0; }
	}

	public class TransitionOrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TransitionOr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTransitionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cTransitionOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightTransitionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//TransitionOr returns TransitionExpression:
		//	Transition ({TransitionOr.left=current} "|" right=Transition)*;
		@Override public ParserRule getRule() { return rule; }

		//Transition ({TransitionOr.left=current} "|" right=Transition)*
		public Group getGroup() { return cGroup; }

		//Transition
		public RuleCall getTransitionParserRuleCall_0() { return cTransitionParserRuleCall_0; }

		//({TransitionOr.left=current} "|" right=Transition)*
		public Group getGroup_1() { return cGroup_1; }

		//{TransitionOr.left=current}
		public Action getTransitionOrLeftAction_1_0() { return cTransitionOrLeftAction_1_0; }

		//"|"
		public Keyword getVerticalLineKeyword_1_1() { return cVerticalLineKeyword_1_1; }

		//right=Transition
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Transition
		public RuleCall getRightTransitionParserRuleCall_1_2_0() { return cRightTransitionParserRuleCall_1_2_0; }
	}

	public class TransitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Transition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTransitionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cGuardAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cGuardExpressionParserRuleCall_1_0 = (RuleCall)cGuardAssignment_1.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cActionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cActionInstructionParserRuleCall_3_0 = (RuleCall)cActionAssignment_3.eContents().get(0);
		
		//Transition returns TransitionExpression:
		//	{Transition} guard=Expression "->" action=Instruction;
		@Override public ParserRule getRule() { return rule; }

		//{Transition} guard=Expression "->" action=Instruction
		public Group getGroup() { return cGroup; }

		//{Transition}
		public Action getTransitionAction_0() { return cTransitionAction_0; }

		//guard=Expression
		public Assignment getGuardAssignment_1() { return cGuardAssignment_1; }

		//Expression
		public RuleCall getGuardExpressionParserRuleCall_1_0() { return cGuardExpressionParserRuleCall_1_0; }

		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_2() { return cHyphenMinusGreaterThanSignKeyword_2; }

		//action=Instruction
		public Assignment getActionAssignment_3() { return cActionAssignment_3; }

		//Instruction
		public RuleCall getActionInstructionParserRuleCall_3_0() { return cActionInstructionParserRuleCall_3_0; }
	}

	public class InstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Instruction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSkipParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAssignmentParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBlockParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cConditionalParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cSwitchParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//// ========== Instructions ==========
		//Instruction:
		//	Skip | Assignment | Block | Conditional | Switch;
		@Override public ParserRule getRule() { return rule; }

		//Skip | Assignment | Block | Conditional | Switch
		public Alternatives getAlternatives() { return cAlternatives; }

		//Skip
		public RuleCall getSkipParserRuleCall_0() { return cSkipParserRuleCall_0; }

		//Assignment
		public RuleCall getAssignmentParserRuleCall_1() { return cAssignmentParserRuleCall_1; }

		//Block
		public RuleCall getBlockParserRuleCall_2() { return cBlockParserRuleCall_2; }

		//Conditional
		public RuleCall getConditionalParserRuleCall_3() { return cConditionalParserRuleCall_3; }

		//Switch
		public RuleCall getSwitchParserRuleCall_4() { return cSwitchParserRuleCall_4; }
	}

	public class SkipElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Skip");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSkipAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSkipKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Skip returns Instruction:
		//	{Skip} "skip" ";";
		@Override public ParserRule getRule() { return rule; }

		//{Skip} "skip" ";"
		public Group getGroup() { return cGroup; }

		//{Skip}
		public Action getSkipAction_0() { return cSkipAction_0; }

		//"skip"
		public Keyword getSkipKeyword_1() { return cSkipKeyword_1; }

		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Assignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAssignmentAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cVariableAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVariableNameRefParserRuleCall_1_0 = (RuleCall)cVariableAssignment_1.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueExpressionParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Assignment returns Instruction:
		//	{Assignment} variable=NameRef ":=" value=Expression ";";
		@Override public ParserRule getRule() { return rule; }

		//{Assignment} variable=NameRef ":=" value=Expression ";"
		public Group getGroup() { return cGroup; }

		//{Assignment}
		public Action getAssignmentAction_0() { return cAssignmentAction_0; }

		//variable=NameRef
		public Assignment getVariableAssignment_1() { return cVariableAssignment_1; }

		//NameRef
		public RuleCall getVariableNameRefParserRuleCall_1_0() { return cVariableNameRefParserRuleCall_1_0; }

		//":="
		public Keyword getColonEqualsSignKeyword_2() { return cColonEqualsSignKeyword_2; }

		//value=Expression
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_3_0() { return cValueExpressionParserRuleCall_3_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBlockAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cInstructionsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cInstructionsInstructionParserRuleCall_2_0 = (RuleCall)cInstructionsAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Block returns Instruction:
		//	{Block} "{" instructions+=Instruction+ "}";
		@Override public ParserRule getRule() { return rule; }

		//{Block} "{" instructions+=Instruction+ "}"
		public Group getGroup() { return cGroup; }

		//{Block}
		public Action getBlockAction_0() { return cBlockAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//instructions+=Instruction+
		public Assignment getInstructionsAssignment_2() { return cInstructionsAssignment_2; }

		//Instruction
		public RuleCall getInstructionsInstructionParserRuleCall_2_0() { return cInstructionsInstructionParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class ConditionalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Conditional");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cConditionalAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cIfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConditionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConditionExpressionParserRuleCall_2_0 = (RuleCall)cConditionAssignment_2.eContents().get(0);
		private final Keyword cThenKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cThenAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cThenInstructionParserRuleCall_4_0 = (RuleCall)cThenAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cElseKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cElseAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cElseInstructionParserRuleCall_5_1_0 = (RuleCall)cElseAssignment_5_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//Conditional returns Instruction:
		//	{Conditional} "if" condition=Expression "then" then=Instruction ("else" else=Instruction)? ";";
		@Override public ParserRule getRule() { return rule; }

		//{Conditional} "if" condition=Expression "then" then=Instruction ("else" else=Instruction)? ";"
		public Group getGroup() { return cGroup; }

		//{Conditional}
		public Action getConditionalAction_0() { return cConditionalAction_0; }

		//"if"
		public Keyword getIfKeyword_1() { return cIfKeyword_1; }

		//condition=Expression
		public Assignment getConditionAssignment_2() { return cConditionAssignment_2; }

		//Expression
		public RuleCall getConditionExpressionParserRuleCall_2_0() { return cConditionExpressionParserRuleCall_2_0; }

		//"then"
		public Keyword getThenKeyword_3() { return cThenKeyword_3; }

		//then=Instruction
		public Assignment getThenAssignment_4() { return cThenAssignment_4; }

		//Instruction
		public RuleCall getThenInstructionParserRuleCall_4_0() { return cThenInstructionParserRuleCall_4_0; }

		//(=> "else" else=Instruction)?
		public Group getGroup_5() { return cGroup_5; }

		//=> "else"
		public Keyword getElseKeyword_5_0() { return cElseKeyword_5_0; }

		//else=Instruction
		public Assignment getElseAssignment_5_1() { return cElseAssignment_5_1; }

		//Instruction
		public RuleCall getElseInstructionParserRuleCall_5_1_0() { return cElseInstructionParserRuleCall_5_1_0; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class SwitchElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Switch");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSwitchKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cCasesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCasesCaseExpressionParserRuleCall_2_0 = (RuleCall)cCasesAssignment_2.eContents().get(0);
		private final Keyword cElseKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cColonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cElseAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cElseExpressionParserRuleCall_5_0 = (RuleCall)cElseAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//Switch returns Instruction:
		//	"switch" "{" cases+=CaseExpression* "else" ":" else=Expression "}";
		@Override public ParserRule getRule() { return rule; }

		//"switch" "{" cases+=CaseExpression* "else" ":" else=Expression "}"
		public Group getGroup() { return cGroup; }

		//"switch"
		public Keyword getSwitchKeyword_0() { return cSwitchKeyword_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//cases+=CaseExpression*
		public Assignment getCasesAssignment_2() { return cCasesAssignment_2; }

		//CaseExpression
		public RuleCall getCasesCaseExpressionParserRuleCall_2_0() { return cCasesCaseExpressionParserRuleCall_2_0; }

		//"else"
		public Keyword getElseKeyword_3() { return cElseKeyword_3; }

		//":"
		public Keyword getColonKeyword_4() { return cColonKeyword_4; }

		//else=Expression
		public Assignment getElseAssignment_5() { return cElseAssignment_5; }

		//Expression
		public RuleCall getElseExpressionParserRuleCall_5_0() { return cElseExpressionParserRuleCall_5_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final RuleCall cLogicalOrParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// ========== Expressions ==========
		//Expression:
		//	LogicalOr;
		@Override public ParserRule getRule() { return rule; }

		//LogicalOr
		public RuleCall getLogicalOrParserRuleCall() { return cLogicalOrParserRuleCall; }
	}

	public class LogicalOrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalOr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLogicalAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cLogicalOrLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final Keyword cOpOrKeyword_1_0_1_0 = (Keyword)cOpAssignment_1_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cRightLogicalAndParserRuleCall_1_0_2_0 = (RuleCall)cRightAssignment_1_0_2.eContents().get(0);
		
		//LogicalOr returns Expression:
		//	LogicalAnd => ({LogicalOr.left=current} op="or" right=LogicalAnd)*;
		@Override public ParserRule getRule() { return rule; }

		//LogicalAnd => ({LogicalOr.left=current} op="or" right=LogicalAnd)*
		public Group getGroup() { return cGroup; }

		//LogicalAnd
		public RuleCall getLogicalAndParserRuleCall_0() { return cLogicalAndParserRuleCall_0; }

		//=> ({LogicalOr.left=current} op="or" right=LogicalAnd)*
		public Group getGroup_1() { return cGroup_1; }

		//{LogicalOr.left=current} op="or" right=LogicalAnd
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{LogicalOr.left=current}
		public Action getLogicalOrLeftAction_1_0_0() { return cLogicalOrLeftAction_1_0_0; }

		//op="or"
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }

		//"or"
		public Keyword getOpOrKeyword_1_0_1_0() { return cOpOrKeyword_1_0_1_0; }

		//right=LogicalAnd
		public Assignment getRightAssignment_1_0_2() { return cRightAssignment_1_0_2; }

		//LogicalAnd
		public RuleCall getRightLogicalAndParserRuleCall_1_0_2_0() { return cRightLogicalAndParserRuleCall_1_0_2_0; }
	}

	public class LogicalAndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalAnd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRelationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cLogicalAndLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final Keyword cOpAndKeyword_1_0_1_0 = (Keyword)cOpAssignment_1_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cRightRelationParserRuleCall_1_0_2_0 = (RuleCall)cRightAssignment_1_0_2.eContents().get(0);
		
		//LogicalAnd returns Expression:
		//	Relation => ({LogicalAnd.left=current} op="and" right=Relation)*;
		@Override public ParserRule getRule() { return rule; }

		//Relation => ({LogicalAnd.left=current} op="and" right=Relation)*
		public Group getGroup() { return cGroup; }

		//Relation
		public RuleCall getRelationParserRuleCall_0() { return cRelationParserRuleCall_0; }

		//=> ({LogicalAnd.left=current} op="and" right=Relation)*
		public Group getGroup_1() { return cGroup_1; }

		//{LogicalAnd.left=current} op="and" right=Relation
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{LogicalAnd.left=current}
		public Action getLogicalAndLeftAction_1_0_0() { return cLogicalAndLeftAction_1_0_0; }

		//op="and"
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }

		//"and"
		public Keyword getOpAndKeyword_1_0_1_0() { return cOpAndKeyword_1_0_1_0; }

		//right=Relation
		public Assignment getRightAssignment_1_0_2() { return cRightAssignment_1_0_2; }

		//Relation
		public RuleCall getRightRelationParserRuleCall_1_0_2_0() { return cRightRelationParserRuleCall_1_0_2_0; }
	}

	public class RelationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Relation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cEqualLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final Alternatives cOpAlternatives_1_0_1_0 = (Alternatives)cOpAssignment_1_0_1.eContents().get(0);
		private final Keyword cOpEqualsSignEqualsSignKeyword_1_0_1_0_0 = (Keyword)cOpAlternatives_1_0_1_0.eContents().get(0);
		private final Keyword cOpExclamationMarkEqualsSignKeyword_1_0_1_0_1 = (Keyword)cOpAlternatives_1_0_1_0.eContents().get(1);
		private final Keyword cOpLessThanSignKeyword_1_0_1_0_2 = (Keyword)cOpAlternatives_1_0_1_0.eContents().get(2);
		private final Keyword cOpLessThanSignEqualsSignKeyword_1_0_1_0_3 = (Keyword)cOpAlternatives_1_0_1_0.eContents().get(3);
		private final Keyword cOpGreaterThanSignEqualsSignKeyword_1_0_1_0_4 = (Keyword)cOpAlternatives_1_0_1_0.eContents().get(4);
		private final Keyword cOpGreaterThanSignKeyword_1_0_1_0_5 = (Keyword)cOpAlternatives_1_0_1_0.eContents().get(5);
		private final Assignment cRightAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cRightAdditionParserRuleCall_1_0_2_0 = (RuleCall)cRightAssignment_1_0_2.eContents().get(0);
		
		//Relation returns Expression:
		//	Addition => ({Equal.left=current} op=("==" | "!=" | "<" | "<=" | ">=" | ">") right=Addition)*;
		@Override public ParserRule getRule() { return rule; }

		//Addition => ({Equal.left=current} op=("==" | "!=" | "<" | "<=" | ">=" | ">") right=Addition)*
		public Group getGroup() { return cGroup; }

		//Addition
		public RuleCall getAdditionParserRuleCall_0() { return cAdditionParserRuleCall_0; }

		//=> ({Equal.left=current} op=("==" | "!=" | "<" | "<=" | ">=" | ">") right=Addition)*
		public Group getGroup_1() { return cGroup_1; }

		//{Equal.left=current} op=("==" | "!=" | "<" | "<=" | ">=" | ">") right=Addition
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{Equal.left=current}
		public Action getEqualLeftAction_1_0_0() { return cEqualLeftAction_1_0_0; }

		//op=("==" | "!=" | "<" | "<=" | ">=" | ">")
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }

		//"==" | "!=" | "<" | "<=" | ">=" | ">"
		public Alternatives getOpAlternatives_1_0_1_0() { return cOpAlternatives_1_0_1_0; }

		//"=="
		public Keyword getOpEqualsSignEqualsSignKeyword_1_0_1_0_0() { return cOpEqualsSignEqualsSignKeyword_1_0_1_0_0; }

		//"!="
		public Keyword getOpExclamationMarkEqualsSignKeyword_1_0_1_0_1() { return cOpExclamationMarkEqualsSignKeyword_1_0_1_0_1; }

		//"<"
		public Keyword getOpLessThanSignKeyword_1_0_1_0_2() { return cOpLessThanSignKeyword_1_0_1_0_2; }

		//"<="
		public Keyword getOpLessThanSignEqualsSignKeyword_1_0_1_0_3() { return cOpLessThanSignEqualsSignKeyword_1_0_1_0_3; }

		//">="
		public Keyword getOpGreaterThanSignEqualsSignKeyword_1_0_1_0_4() { return cOpGreaterThanSignEqualsSignKeyword_1_0_1_0_4; }

		//">"
		public Keyword getOpGreaterThanSignKeyword_1_0_1_0_5() { return cOpGreaterThanSignKeyword_1_0_1_0_5; }

		//right=Addition
		public Assignment getRightAssignment_1_0_2() { return cRightAssignment_1_0_2; }

		//Addition
		public RuleCall getRightAdditionParserRuleCall_1_0_2_0() { return cRightAdditionParserRuleCall_1_0_2_0; }
	}

	public class AdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Addition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cAdditionLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final Alternatives cOpAlternatives_1_0_1_0 = (Alternatives)cOpAssignment_1_0_1.eContents().get(0);
		private final Keyword cOpPlusSignKeyword_1_0_1_0_0 = (Keyword)cOpAlternatives_1_0_1_0.eContents().get(0);
		private final Keyword cOpHyphenMinusKeyword_1_0_1_0_1 = (Keyword)cOpAlternatives_1_0_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cRightMultiplicationParserRuleCall_1_0_2_0 = (RuleCall)cRightAssignment_1_0_2.eContents().get(0);
		
		//Addition returns Expression:
		//	Multiplication => ({Addition.left=current} op=("+" | "-") right=Multiplication)*;
		@Override public ParserRule getRule() { return rule; }

		//Multiplication => ({Addition.left=current} op=("+" | "-") right=Multiplication)*
		public Group getGroup() { return cGroup; }

		//Multiplication
		public RuleCall getMultiplicationParserRuleCall_0() { return cMultiplicationParserRuleCall_0; }

		//=> ({Addition.left=current} op=("+" | "-") right=Multiplication)*
		public Group getGroup_1() { return cGroup_1; }

		//{Addition.left=current} op=("+" | "-") right=Multiplication
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{Addition.left=current}
		public Action getAdditionLeftAction_1_0_0() { return cAdditionLeftAction_1_0_0; }

		//op=("+" | "-")
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }

		//"+" | "-"
		public Alternatives getOpAlternatives_1_0_1_0() { return cOpAlternatives_1_0_1_0; }

		//"+"
		public Keyword getOpPlusSignKeyword_1_0_1_0_0() { return cOpPlusSignKeyword_1_0_1_0_0; }

		//"-"
		public Keyword getOpHyphenMinusKeyword_1_0_1_0_1() { return cOpHyphenMinusKeyword_1_0_1_0_1; }

		//right=Multiplication
		public Assignment getRightAssignment_1_0_2() { return cRightAssignment_1_0_2; }

		//Multiplication
		public RuleCall getRightMultiplicationParserRuleCall_1_0_2_0() { return cRightMultiplicationParserRuleCall_1_0_2_0; }
	}

	public class MultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Multiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNegParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cMultiplicationLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final Alternatives cOpAlternatives_1_0_1_0 = (Alternatives)cOpAssignment_1_0_1.eContents().get(0);
		private final Keyword cOpAsteriskKeyword_1_0_1_0_0 = (Keyword)cOpAlternatives_1_0_1_0.eContents().get(0);
		private final Keyword cOpSolidusKeyword_1_0_1_0_1 = (Keyword)cOpAlternatives_1_0_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cRightNegParserRuleCall_1_0_2_0 = (RuleCall)cRightAssignment_1_0_2.eContents().get(0);
		
		//Multiplication returns Expression:
		//	Neg => ({Multiplication.left=current} op=("*" | "/") right=Neg)*;
		@Override public ParserRule getRule() { return rule; }

		//Neg => ({Multiplication.left=current} op=("*" | "/") right=Neg)*
		public Group getGroup() { return cGroup; }

		//Neg
		public RuleCall getNegParserRuleCall_0() { return cNegParserRuleCall_0; }

		//=> ({Multiplication.left=current} op=("*" | "/") right=Neg)*
		public Group getGroup_1() { return cGroup_1; }

		//{Multiplication.left=current} op=("*" | "/") right=Neg
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{Multiplication.left=current}
		public Action getMultiplicationLeftAction_1_0_0() { return cMultiplicationLeftAction_1_0_0; }

		//op=("*" | "/")
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }

		//"*" | "/"
		public Alternatives getOpAlternatives_1_0_1_0() { return cOpAlternatives_1_0_1_0; }

		//"*"
		public Keyword getOpAsteriskKeyword_1_0_1_0_0() { return cOpAsteriskKeyword_1_0_1_0_0; }

		//"/"
		public Keyword getOpSolidusKeyword_1_0_1_0_1() { return cOpSolidusKeyword_1_0_1_0_1; }

		//right=Neg
		public Assignment getRightAssignment_1_0_2() { return cRightAssignment_1_0_2; }

		//Neg
		public RuleCall getRightNegParserRuleCall_1_0_2_0() { return cRightNegParserRuleCall_1_0_2_0; }
	}

	public class NegElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Neg");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cNotAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cNotKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cExpressionAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cExpressionAtomParserRuleCall_0_2_0 = (RuleCall)cExpressionAssignment_0_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cMinusAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExpressionAtomParserRuleCall_1_2_0 = (RuleCall)cExpressionAssignment_1_2.eContents().get(0);
		private final RuleCall cAtomParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Neg returns Expression:
		//	{Not} => "not" expression=Atom | {Minus} => "-" expression=Atom | Atom;
		@Override public ParserRule getRule() { return rule; }

		//{Not} => "not" expression=Atom | {Minus} => "-" expression=Atom | Atom
		public Alternatives getAlternatives() { return cAlternatives; }

		//{Not} => "not" expression=Atom
		public Group getGroup_0() { return cGroup_0; }

		//{Not}
		public Action getNotAction_0_0() { return cNotAction_0_0; }

		//=> "not"
		public Keyword getNotKeyword_0_1() { return cNotKeyword_0_1; }

		//expression=Atom
		public Assignment getExpressionAssignment_0_2() { return cExpressionAssignment_0_2; }

		//Atom
		public RuleCall getExpressionAtomParserRuleCall_0_2_0() { return cExpressionAtomParserRuleCall_0_2_0; }

		//{Minus} => "-" expression=Atom
		public Group getGroup_1() { return cGroup_1; }

		//{Minus}
		public Action getMinusAction_1_0() { return cMinusAction_1_0; }

		//=> "-"
		public Keyword getHyphenMinusKeyword_1_1() { return cHyphenMinusKeyword_1_1; }

		//expression=Atom
		public Assignment getExpressionAssignment_1_2() { return cExpressionAssignment_1_2; }

		//Atom
		public RuleCall getExpressionAtomParserRuleCall_1_2_0() { return cExpressionAtomParserRuleCall_1_2_0; }

		//Atom
		public RuleCall getAtomParserRuleCall_2() { return cAtomParserRuleCall_2; }
	}

	public class AtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Atom");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBooleanLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStringLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIntegerLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cNameRefParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cSwitchExpressionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Keyword cLeftParenthesisKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_5_1 = (RuleCall)cGroup_5.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_5_2 = (Keyword)cGroup_5.eContents().get(2);
		
		//Atom returns Expression:
		//	BooleanLiteral | StringLiteral | IntegerLiteral | NameRef | SwitchExpression | "(" Expression ")";
		@Override public ParserRule getRule() { return rule; }

		//BooleanLiteral | StringLiteral | IntegerLiteral | NameRef | SwitchExpression | "(" Expression ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//BooleanLiteral
		public RuleCall getBooleanLiteralParserRuleCall_0() { return cBooleanLiteralParserRuleCall_0; }

		//StringLiteral
		public RuleCall getStringLiteralParserRuleCall_1() { return cStringLiteralParserRuleCall_1; }

		//IntegerLiteral
		public RuleCall getIntegerLiteralParserRuleCall_2() { return cIntegerLiteralParserRuleCall_2; }

		//NameRef
		public RuleCall getNameRefParserRuleCall_3() { return cNameRefParserRuleCall_3; }

		//SwitchExpression
		public RuleCall getSwitchExpressionParserRuleCall_4() { return cSwitchExpressionParserRuleCall_4; }

		//"(" Expression ")"
		public Group getGroup_5() { return cGroup_5; }

		//"("
		public Keyword getLeftParenthesisKeyword_5_0() { return cLeftParenthesisKeyword_5_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_5_1() { return cExpressionParserRuleCall_5_1; }

		//")"
		public Keyword getRightParenthesisKeyword_5_2() { return cRightParenthesisKeyword_5_2; }
	}

	public class BooleanLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cValueAlternatives_0 = (Alternatives)cValueAssignment.eContents().get(0);
		private final Keyword cValueTrueKeyword_0_0 = (Keyword)cValueAlternatives_0.eContents().get(0);
		private final Keyword cValueFalseKeyword_0_1 = (Keyword)cValueAlternatives_0.eContents().get(1);
		
		//BooleanLiteral returns ARBoolean:
		//	value=("true" | "false");
		@Override public ParserRule getRule() { return rule; }

		//value=("true" | "false")
		public Assignment getValueAssignment() { return cValueAssignment; }

		//"true" | "false"
		public Alternatives getValueAlternatives_0() { return cValueAlternatives_0; }

		//"true"
		public Keyword getValueTrueKeyword_0_0() { return cValueTrueKeyword_0_0; }

		//"false"
		public Keyword getValueFalseKeyword_0_1() { return cValueFalseKeyword_0_1; }
	}

	public class StringLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StringLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//StringLiteral returns ARString:
		//	value=STRING;
		@Override public ParserRule getRule() { return rule; }

		//value=STRING
		public Assignment getValueAssignment() { return cValueAssignment; }

		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_0() { return cValueSTRINGTerminalRuleCall_0; }
	}

	public class IntegerLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IntegerLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//IntegerLiteral returns ARInteger:
		//	value=INT;
		@Override public ParserRule getRule() { return rule; }

		//value=INT
		public Assignment getValueAssignment() { return cValueAssignment; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_0() { return cValueINTTerminalRuleCall_0; }
	}

	public class NameRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NameRef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVariableAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cVariableNamedElementCrossReference_0_0 = (CrossReference)cVariableAssignment_0.eContents().get(0);
		private final RuleCall cVariableNamedElementIDTerminalRuleCall_0_0_1 = (RuleCall)cVariableNamedElementCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cNameRefNestedAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Keyword cFullStopKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Assignment cVariableAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final CrossReference cVariableNamedElementCrossReference_1_0_2_0 = (CrossReference)cVariableAssignment_1_0_2.eContents().get(0);
		private final RuleCall cVariableNamedElementIDTerminalRuleCall_1_0_2_0_1 = (RuleCall)cVariableNamedElementCrossReference_1_0_2_0.eContents().get(1);
		
		//NameRef:
		//	variable=[NamedElement] => ({NameRef.nested=current} "." variable=[NamedElement])*;
		@Override public ParserRule getRule() { return rule; }

		//variable=[NamedElement] => ({NameRef.nested=current} "." variable=[NamedElement])*
		public Group getGroup() { return cGroup; }

		//variable=[NamedElement]
		public Assignment getVariableAssignment_0() { return cVariableAssignment_0; }

		//[NamedElement]
		public CrossReference getVariableNamedElementCrossReference_0_0() { return cVariableNamedElementCrossReference_0_0; }

		//ID
		public RuleCall getVariableNamedElementIDTerminalRuleCall_0_0_1() { return cVariableNamedElementIDTerminalRuleCall_0_0_1; }

		//=> ({NameRef.nested=current} "." variable=[NamedElement])*
		public Group getGroup_1() { return cGroup_1; }

		//{NameRef.nested=current} "." variable=[NamedElement]
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{NameRef.nested=current}
		public Action getNameRefNestedAction_1_0_0() { return cNameRefNestedAction_1_0_0; }

		//"."
		public Keyword getFullStopKeyword_1_0_1() { return cFullStopKeyword_1_0_1; }

		//variable=[NamedElement]
		public Assignment getVariableAssignment_1_0_2() { return cVariableAssignment_1_0_2; }

		//[NamedElement]
		public CrossReference getVariableNamedElementCrossReference_1_0_2_0() { return cVariableNamedElementCrossReference_1_0_2_0; }

		//ID
		public RuleCall getVariableNamedElementIDTerminalRuleCall_1_0_2_0_1() { return cVariableNamedElementIDTerminalRuleCall_1_0_2_0_1; }
	}

	public class SwitchExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SwitchExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSwitchKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cCasesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCasesCaseExpressionParserRuleCall_2_0 = (RuleCall)cCasesAssignment_2.eContents().get(0);
		private final Keyword cElseKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cColonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cDefaultAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cDefaultExpressionParserRuleCall_5_0 = (RuleCall)cDefaultAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//SwitchExpression:
		//	"switch" "{" cases+=CaseExpression* "else" ":" default=Expression "}";
		@Override public ParserRule getRule() { return rule; }

		//"switch" "{" cases+=CaseExpression* "else" ":" default=Expression "}"
		public Group getGroup() { return cGroup; }

		//"switch"
		public Keyword getSwitchKeyword_0() { return cSwitchKeyword_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//cases+=CaseExpression*
		public Assignment getCasesAssignment_2() { return cCasesAssignment_2; }

		//CaseExpression
		public RuleCall getCasesCaseExpressionParserRuleCall_2_0() { return cCasesCaseExpressionParserRuleCall_2_0; }

		//"else"
		public Keyword getElseKeyword_3() { return cElseKeyword_3; }

		//":"
		public Keyword getColonKeyword_4() { return cColonKeyword_4; }

		//default=Expression
		public Assignment getDefaultAssignment_5() { return cDefaultAssignment_5; }

		//Expression
		public RuleCall getDefaultExpressionParserRuleCall_5_0() { return cDefaultExpressionParserRuleCall_5_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}

	public class CaseExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CaseExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cConditionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cConditionLogicalOrParserRuleCall_0_0 = (RuleCall)cConditionAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cCaseAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCaseExpressionParserRuleCall_2_0 = (RuleCall)cCaseAssignment_2.eContents().get(0);
		
		//CaseExpression:
		//	condition=LogicalOr ":" case=Expression;
		@Override public ParserRule getRule() { return rule; }

		//condition=LogicalOr ":" case=Expression
		public Group getGroup() { return cGroup; }

		//condition=LogicalOr
		public Assignment getConditionAssignment_0() { return cConditionAssignment_0; }

		//LogicalOr
		public RuleCall getConditionLogicalOrParserRuleCall_0_0() { return cConditionLogicalOrParserRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//case=Expression
		public Assignment getCaseAssignment_2() { return cCaseAssignment_2; }

		//Expression
		public RuleCall getCaseExpressionParserRuleCall_2_0() { return cCaseExpressionParserRuleCall_2_0; }
	}
	
	
	public class BaseTypeEnumElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "BaseTypeEnum");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cINTEGEREnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cINTEGERIntegerKeyword_0_0 = (Keyword)cINTEGEREnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cBOOLEANEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cBOOLEANBooleanKeyword_1_0 = (Keyword)cBOOLEANEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum BaseTypeEnum:
		//	INTEGER="Integer" | BOOLEAN="Boolean";
		public EnumRule getRule() { return rule; }

		//INTEGER="Integer" | BOOLEAN="Boolean"
		public Alternatives getAlternatives() { return cAlternatives; }

		//INTEGER="Integer"
		public EnumLiteralDeclaration getINTEGEREnumLiteralDeclaration_0() { return cINTEGEREnumLiteralDeclaration_0; }

		//"Integer"
		public Keyword getINTEGERIntegerKeyword_0_0() { return cINTEGERIntegerKeyword_0_0; }

		//BOOLEAN="Boolean"
		public EnumLiteralDeclaration getBOOLEANEnumLiteralDeclaration_1() { return cBOOLEANEnumLiteralDeclaration_1; }

		//"Boolean"
		public Keyword getBOOLEANBooleanKeyword_1_0() { return cBOOLEANBooleanKeyword_1_0; }
	}
	
	private final ModelElements pModel;
	private final AbstractDeclarationElements pAbstractDeclaration;
	private final DomainElements pDomain;
	private final SymbolicConstantElements pSymbolicConstant;
	private final TypeElements pType;
	private final BaseTypeElements pBaseType;
	private final BaseTypeEnumElements unknownRuleBaseTypeEnum;
	private final NamedTypeElements pNamedType;
	private final ClassElements pClass;
	private final DeclarationElements pDeclaration;
	private final VariableDeclarationElements pVariableDeclaration;
	private final AttributeElements pAttribute;
	private final EventDeclarationElements pEventDeclaration;
	private final ParameterDeclarationElements pParameterDeclaration;
	private final ObserverDeclarationElements pObserverDeclaration;
	private final LabeledTransitionElements pLabeledTransition;
	private final TransitionAndElements pTransitionAnd;
	private final TransitionOrElements pTransitionOr;
	private final TransitionElements pTransition;
	private final InstructionElements pInstruction;
	private final SkipElements pSkip;
	private final AssignmentElements pAssignment;
	private final BlockElements pBlock;
	private final ConditionalElements pConditional;
	private final SwitchElements pSwitch;
	private final ExpressionElements pExpression;
	private final LogicalOrElements pLogicalOr;
	private final LogicalAndElements pLogicalAnd;
	private final RelationElements pRelation;
	private final AdditionElements pAddition;
	private final MultiplicationElements pMultiplication;
	private final NegElements pNeg;
	private final AtomElements pAtom;
	private final BooleanLiteralElements pBooleanLiteral;
	private final StringLiteralElements pStringLiteral;
	private final IntegerLiteralElements pIntegerLiteral;
	private final NameRefElements pNameRef;
	private final SwitchExpressionElements pSwitchExpression;
	private final CaseExpressionElements pCaseExpression;
	private final TerminalRule tALPHA;
	private final TerminalRule tDIGIT;
	private final TerminalRule tREGULAR_ID;
	private final TerminalRule tSTRING_ID;
	private final TerminalRule tID;
	private final TerminalRule tSTRING;
	
	private final Grammar grammar;

	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public AltaricaGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.pAbstractDeclaration = new AbstractDeclarationElements();
		this.pDomain = new DomainElements();
		this.pSymbolicConstant = new SymbolicConstantElements();
		this.pType = new TypeElements();
		this.pBaseType = new BaseTypeElements();
		this.unknownRuleBaseTypeEnum = new BaseTypeEnumElements();
		this.pNamedType = new NamedTypeElements();
		this.pClass = new ClassElements();
		this.pDeclaration = new DeclarationElements();
		this.pVariableDeclaration = new VariableDeclarationElements();
		this.pAttribute = new AttributeElements();
		this.pEventDeclaration = new EventDeclarationElements();
		this.pParameterDeclaration = new ParameterDeclarationElements();
		this.pObserverDeclaration = new ObserverDeclarationElements();
		this.pLabeledTransition = new LabeledTransitionElements();
		this.pTransitionAnd = new TransitionAndElements();
		this.pTransitionOr = new TransitionOrElements();
		this.pTransition = new TransitionElements();
		this.pInstruction = new InstructionElements();
		this.pSkip = new SkipElements();
		this.pAssignment = new AssignmentElements();
		this.pBlock = new BlockElements();
		this.pConditional = new ConditionalElements();
		this.pSwitch = new SwitchElements();
		this.pExpression = new ExpressionElements();
		this.pLogicalOr = new LogicalOrElements();
		this.pLogicalAnd = new LogicalAndElements();
		this.pRelation = new RelationElements();
		this.pAddition = new AdditionElements();
		this.pMultiplication = new MultiplicationElements();
		this.pNeg = new NegElements();
		this.pAtom = new AtomElements();
		this.pBooleanLiteral = new BooleanLiteralElements();
		this.pStringLiteral = new StringLiteralElements();
		this.pIntegerLiteral = new IntegerLiteralElements();
		this.pNameRef = new NameRefElements();
		this.pSwitchExpression = new SwitchExpressionElements();
		this.pCaseExpression = new CaseExpressionElements();
		this.tALPHA = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ALPHA");
		this.tDIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DIGIT");
		this.tREGULAR_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "REGULAR_ID");
		this.tSTRING_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STRING_ID");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ID");
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STRING");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.osate.altarica.Altarica".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//	declarations+=AbstractDeclaration*;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	//AbstractDeclaration:
	//	Domain | Class;
	public AbstractDeclarationElements getAbstractDeclarationAccess() {
		return pAbstractDeclaration;
	}
	
	public ParserRule getAbstractDeclarationRule() {
		return getAbstractDeclarationAccess().getRule();
	}

	//Domain returns NamedElement:
	//	{Domain} "domain" name=ID "{" (constants+=SymbolicConstant ("," constants+=SymbolicConstant)*)? "}";
	public DomainElements getDomainAccess() {
		return pDomain;
	}
	
	public ParserRule getDomainRule() {
		return getDomainAccess().getRule();
	}

	//SymbolicConstant returns NamedElement:
	//	{SymbolicConstant} name=ID;
	public SymbolicConstantElements getSymbolicConstantAccess() {
		return pSymbolicConstant;
	}
	
	public ParserRule getSymbolicConstantRule() {
		return getSymbolicConstantAccess().getRule();
	}

	//Type:
	//	BaseType | NamedType;
	public TypeElements getTypeAccess() {
		return pType;
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}

	//BaseType:
	//	name=BaseTypeEnum;
	public BaseTypeElements getBaseTypeAccess() {
		return pBaseType;
	}
	
	public ParserRule getBaseTypeRule() {
		return getBaseTypeAccess().getRule();
	}

	//enum BaseTypeEnum:
	//	INTEGER="Integer" | BOOLEAN="Boolean";
	public BaseTypeEnumElements getBaseTypeEnumAccess() {
		return unknownRuleBaseTypeEnum;
	}
	
	public EnumRule getBaseTypeEnumRule() {
		return getBaseTypeEnumAccess().getRule();
	}

	//NamedType:
	//	ref=[NamedElement];
	public NamedTypeElements getNamedTypeAccess() {
		return pNamedType;
	}
	
	public ParserRule getNamedTypeRule() {
		return getNamedTypeAccess().getRule();
	}

	//// ========== Classes ==========
	//Class returns NamedElement:
	//	{Node} "class" name=ID declarations+=Declaration* ("transition" transitions+=LabeledTransition+)? ("assertion"
	//	assertions+=Instruction+)? "end";
	public ClassElements getClassAccess() {
		return pClass;
	}
	
	public ParserRule getClassRule() {
		return getClassAccess().getRule();
	}

	//// ========== Declarations ==========
	//Declaration:
	//	VariableDeclaration | EventDeclaration | ParameterDeclaration | ObserverDeclaration;
	public DeclarationElements getDeclarationAccess() {
		return pDeclaration;
	}
	
	public ParserRule getDeclarationRule() {
		return getDeclarationAccess().getRule();
	}

	//VariableDeclaration returns NamedElement:
	//	{Variable} type=Type name=ID ("(" attributes+=Attribute ("," attributes+=Attribute)* ")")? ";";
	public VariableDeclarationElements getVariableDeclarationAccess() {
		return pVariableDeclaration;
	}
	
	public ParserRule getVariableDeclarationRule() {
		return getVariableDeclarationAccess().getRule();
	}

	//Attribute returns NamedElement:
	//	{Attribute} name=ID "=" value=Expression;
	public AttributeElements getAttributeAccess() {
		return pAttribute;
	}
	
	public ParserRule getAttributeRule() {
		return getAttributeAccess().getRule();
	}

	//EventDeclaration returns NamedElement:
	//	{Event} "event" name=ID ("(" attributes+=Attribute ("," attributes+=Attribute)* ")")? ";";
	public EventDeclarationElements getEventDeclarationAccess() {
		return pEventDeclaration;
	}
	
	public ParserRule getEventDeclarationRule() {
		return getEventDeclarationAccess().getRule();
	}

	//ParameterDeclaration returns NamedElement:
	//	{Parameter} "parameter" type=Type name=ID "=" value=Expression ";";
	public ParameterDeclarationElements getParameterDeclarationAccess() {
		return pParameterDeclaration;
	}
	
	public ParserRule getParameterDeclarationRule() {
		return getParameterDeclarationAccess().getRule();
	}

	//ObserverDeclaration returns NamedElement:
	//	{Observer} "observer" type=Type name=ID "=" value=Expression ";";
	public ObserverDeclarationElements getObserverDeclarationAccess() {
		return pObserverDeclaration;
	}
	
	public ParserRule getObserverDeclarationRule() {
		return getObserverDeclarationAccess().getRule();
	}

	//// ========== Transitions ==========
	//LabeledTransition:
	//	event=NameRef ":" expression=TransitionAnd;
	public LabeledTransitionElements getLabeledTransitionAccess() {
		return pLabeledTransition;
	}
	
	public ParserRule getLabeledTransitionRule() {
		return getLabeledTransitionAccess().getRule();
	}

	//TransitionAnd returns TransitionExpression:
	//	TransitionOr ({TransitionAnd.left=current} "&" right=TransitionOr)*;
	public TransitionAndElements getTransitionAndAccess() {
		return pTransitionAnd;
	}
	
	public ParserRule getTransitionAndRule() {
		return getTransitionAndAccess().getRule();
	}

	//TransitionOr returns TransitionExpression:
	//	Transition ({TransitionOr.left=current} "|" right=Transition)*;
	public TransitionOrElements getTransitionOrAccess() {
		return pTransitionOr;
	}
	
	public ParserRule getTransitionOrRule() {
		return getTransitionOrAccess().getRule();
	}

	//Transition returns TransitionExpression:
	//	{Transition} guard=Expression "->" action=Instruction;
	public TransitionElements getTransitionAccess() {
		return pTransition;
	}
	
	public ParserRule getTransitionRule() {
		return getTransitionAccess().getRule();
	}

	//// ========== Instructions ==========
	//Instruction:
	//	Skip | Assignment | Block | Conditional | Switch;
	public InstructionElements getInstructionAccess() {
		return pInstruction;
	}
	
	public ParserRule getInstructionRule() {
		return getInstructionAccess().getRule();
	}

	//Skip returns Instruction:
	//	{Skip} "skip" ";";
	public SkipElements getSkipAccess() {
		return pSkip;
	}
	
	public ParserRule getSkipRule() {
		return getSkipAccess().getRule();
	}

	//Assignment returns Instruction:
	//	{Assignment} variable=NameRef ":=" value=Expression ";";
	public AssignmentElements getAssignmentAccess() {
		return pAssignment;
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}

	//Block returns Instruction:
	//	{Block} "{" instructions+=Instruction+ "}";
	public BlockElements getBlockAccess() {
		return pBlock;
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}

	//Conditional returns Instruction:
	//	{Conditional} "if" condition=Expression "then" then=Instruction ("else" else=Instruction)? ";";
	public ConditionalElements getConditionalAccess() {
		return pConditional;
	}
	
	public ParserRule getConditionalRule() {
		return getConditionalAccess().getRule();
	}

	//Switch returns Instruction:
	//	"switch" "{" cases+=CaseExpression* "else" ":" else=Expression "}";
	public SwitchElements getSwitchAccess() {
		return pSwitch;
	}
	
	public ParserRule getSwitchRule() {
		return getSwitchAccess().getRule();
	}

	//// ========== Expressions ==========
	//Expression:
	//	LogicalOr;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//LogicalOr returns Expression:
	//	LogicalAnd => ({LogicalOr.left=current} op="or" right=LogicalAnd)*;
	public LogicalOrElements getLogicalOrAccess() {
		return pLogicalOr;
	}
	
	public ParserRule getLogicalOrRule() {
		return getLogicalOrAccess().getRule();
	}

	//LogicalAnd returns Expression:
	//	Relation => ({LogicalAnd.left=current} op="and" right=Relation)*;
	public LogicalAndElements getLogicalAndAccess() {
		return pLogicalAnd;
	}
	
	public ParserRule getLogicalAndRule() {
		return getLogicalAndAccess().getRule();
	}

	//Relation returns Expression:
	//	Addition => ({Equal.left=current} op=("==" | "!=" | "<" | "<=" | ">=" | ">") right=Addition)*;
	public RelationElements getRelationAccess() {
		return pRelation;
	}
	
	public ParserRule getRelationRule() {
		return getRelationAccess().getRule();
	}

	//Addition returns Expression:
	//	Multiplication => ({Addition.left=current} op=("+" | "-") right=Multiplication)*;
	public AdditionElements getAdditionAccess() {
		return pAddition;
	}
	
	public ParserRule getAdditionRule() {
		return getAdditionAccess().getRule();
	}

	//Multiplication returns Expression:
	//	Neg => ({Multiplication.left=current} op=("*" | "/") right=Neg)*;
	public MultiplicationElements getMultiplicationAccess() {
		return pMultiplication;
	}
	
	public ParserRule getMultiplicationRule() {
		return getMultiplicationAccess().getRule();
	}

	//Neg returns Expression:
	//	{Not} => "not" expression=Atom | {Minus} => "-" expression=Atom | Atom;
	public NegElements getNegAccess() {
		return pNeg;
	}
	
	public ParserRule getNegRule() {
		return getNegAccess().getRule();
	}

	//Atom returns Expression:
	//	BooleanLiteral | StringLiteral | IntegerLiteral | NameRef | SwitchExpression | "(" Expression ")";
	public AtomElements getAtomAccess() {
		return pAtom;
	}
	
	public ParserRule getAtomRule() {
		return getAtomAccess().getRule();
	}

	//BooleanLiteral returns ARBoolean:
	//	value=("true" | "false");
	public BooleanLiteralElements getBooleanLiteralAccess() {
		return pBooleanLiteral;
	}
	
	public ParserRule getBooleanLiteralRule() {
		return getBooleanLiteralAccess().getRule();
	}

	//StringLiteral returns ARString:
	//	value=STRING;
	public StringLiteralElements getStringLiteralAccess() {
		return pStringLiteral;
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}

	//IntegerLiteral returns ARInteger:
	//	value=INT;
	public IntegerLiteralElements getIntegerLiteralAccess() {
		return pIntegerLiteral;
	}
	
	public ParserRule getIntegerLiteralRule() {
		return getIntegerLiteralAccess().getRule();
	}

	//NameRef:
	//	variable=[NamedElement] => ({NameRef.nested=current} "." variable=[NamedElement])*;
	public NameRefElements getNameRefAccess() {
		return pNameRef;
	}
	
	public ParserRule getNameRefRule() {
		return getNameRefAccess().getRule();
	}

	//SwitchExpression:
	//	"switch" "{" cases+=CaseExpression* "else" ":" default=Expression "}";
	public SwitchExpressionElements getSwitchExpressionAccess() {
		return pSwitchExpression;
	}
	
	public ParserRule getSwitchExpressionRule() {
		return getSwitchExpressionAccess().getRule();
	}

	//CaseExpression:
	//	condition=LogicalOr ":" case=Expression;
	public CaseExpressionElements getCaseExpressionAccess() {
		return pCaseExpression;
	}
	
	public ParserRule getCaseExpressionRule() {
		return getCaseExpressionAccess().getRule();
	}

	////===== Terminals
	//terminal fragment ALPHA:
	//	"a".."z" | "A".."Z";
	public TerminalRule getALPHARule() {
		return tALPHA;
	} 

	//terminal fragment DIGIT:
	//	"0".."9";
	public TerminalRule getDIGITRule() {
		return tDIGIT;
	} 

	//terminal fragment REGULAR_ID:
	//	(ALPHA | "_") (ALPHA | "_" | DIGIT)*;
	public TerminalRule getREGULAR_IDRule() {
		return tREGULAR_ID;
	} 

	//terminal fragment STRING_ID:
	//	"\'" (ALPHA | DIGIT | "!" | "#" | "$" | "%" | "&" | "(" | ")" | "*" | "+" | "," | "-" | "." | "/" | ":" | ";" | "<" |
	//	">" | "=" | "?" | "@" | "[" | "]" | "^" | "{" | "}" | "|" | "~" | "_")* "\'";
	public TerminalRule getSTRING_IDRule() {
		return tSTRING_ID;
	} 

	//terminal ID:
	//	REGULAR_ID | STRING_ID;
	public TerminalRule getIDRule() {
		return tID;
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\"";
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
