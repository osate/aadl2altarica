-- @atlcompiler emftvm
-- @nsURI AR=http://osate.org/Altarica
-- @nsURI AADL=http://aadl.info/AADL/2.0/instance
-- @nsURI AADL2=http://aadl.info/AADL/2.0
-- @nsURI EMV2=http://www.aadl.info/EMV2


module AADL2AltaRica;
create OUT: AR from IN: AADL;

-- Replace invalid characters in identifier with '_'
helper context String def: normalizeId(): String =
	self.replaceAll('[:.]', '_');

-- Get the component classifier for a compoent instance
helper context AADL!ComponentInstance def: componentClassifier(): AADL2!ComponentClassifier =
	"#native"!"org::osate::aadl2::instance::util::InstanceUtil".refInvokeStaticOperation(
		'getComponentClassifier', Sequence{self, 0, OclUndefined}
	);

helper def: nodeForClassifier: Map(AADL2!ComponentClassifier, AR!Node) = Map{};

helper def: classifierForNodeInstance: Map(AR!NodeInstance, AADL!ComponentClassifier) = Map{};
	
lazy rule makeNodeInstance {
	from
		ci: AADL!ComponentInstance
	to
		ni: AR!NodeInstance (
			name <- ci.name
		)
	do {
		thisModule.classifierForNodeInstance <- thisModule.classifierForNodeInstance -> including(ni, ci.componentClassifier());
		ni;
	}
}

lazy rule subNodes {
	from
		ci: AADL!ComponentInstance
	to
		nis: AR!NodeInstanceSpecification (
			ownedNodeInstances <- ci.componentInstance -> collect(s | thisModule.makeNodeInstance(s))
		)
}

-- Nodes are based on classifiers
-- Problem: can't pass ci to create subnodes
helper def: processedClassifiers: Set(AADL2!ComponentClassifier) = Set{};

lazy rule makeNode {
	from
		c: AADL2!ComponentClassifier,
	  ci: AADL!ComponentInstance (
	  	not thisModule.processedClassifiers.contains(c)
	  )
	to
		n: AR!Node (
			name <- c.qualifiedName().normalizeId(),
			ownedSpecifications <- 
					if not ci.componentInstance.isEmpty() then
						Sequence{thisModule.subNodes(ci)}
					else
						Sequence{}
					endif
		)
	do {
		thisModule.processedClassifiers <:= thisModule.processedClassifiers.including(c);
		thisModule.nodeForClassifier <:= thisModule.nodeForClassifier.including(c, n);
		n;
	}
}

rule SystemInstance {
	from
		si: AADL!SystemInstance
	to
		s: AR!System (
			ownedDeclarations <- AADL!ComponentInstance.allInstances() 
					-> collect(ci | thisModule.makeNode(ci.componentClassifier(), ci))
					-> iterate(n; acc: Sequence(AR!Node) = Sequence{} | if n.oclIsUndefined() then acc else acc.append(n) endif)
					-> debug()
		)
}

endpoint rule Finalize() {
	do {
		-- Add the types to subnodes	
		for (ni in thisModule.classifierForNodeInstance.getKeys()) {
			ni.nodeType <- 
				let c: AADL2!ComponentClassifier =
					thisModule.classifierForNodeInstance.get(ni)
				in
					thisModule.nodeForClassifier.get(c);
		}
	}
}
