-- @atlcompiler emftvm
-- @nsURI AR=http://osate.org/Altarica/2.1
-- @nsURI AADL=http://aadl.info/AADL/2.0/instance
-- @nsURI AADL2=http://aadl.info/AADL/2.0
-- @nsURI EMV2=http://www.aadl.info/EMV2

library Util;

-- The component classifier for a component instance
helper context AADL!ComponentInstance def: classifier: AADL2!ComponentClassifier =
	"#native"!"org::osate::aadl2::instance::util::InstanceUtil".refInvokeStaticOperation(
		'getComponentClassifier', Sequence{self, 0, OclUndefined}
	);

helper context AADL!ComponentInstance def: isLeaf: Boolean =
	thisModule.emLeafComponents -> contains(self);

-- Helpers for EMV2 processing

helper context AADL2!Classifier def: outgoingErrorPropagations(): Sequence(EMV2!ErrorPropagation) =
	"#native"!"org::osate::xtext::aadl2::errormodel::util::EMV2Util".refInvokeStaticOperation(
		'getAllOutgoingErrorPropagations', Sequence{self}
	);

helper context AADL2!Classifier def: incomingErrorPropagations(): Sequence(EMV2!ErrorPropagation) =
	"#native"!"org::osate::xtext::aadl2::errormodel::util::EMV2Util".refInvokeStaticOperation(
		'getAllIncomingErrorPropagations', Sequence{self}
	);

helper context AADL2!Classifier def: errorPropagations(): Sequence(EMV2!ErrorPropagation) =
	self.incomingErrorPropagations() -> including(self.outgoingErrorPropagations()) -> flatten();

helper context AADL2!Classifier def: usedTypes(): Sequence(EMV2!ErrorModelLibrary) =
	"#native"!"org::osate::xtext::aadl2::errormodel::util::EMV2Util".refInvokeStaticOperation(
		'getErrorModelSubclauseWithUseTypes', Sequence{self}
	);

helper context AADL2!Classifier def: errorEvents(): Collection(EMV2!ErrorBehaviorEvent) =
	"#native"!"org::osate::xtext::aadl2::errormodel::util::EMV2Util".refInvokeStaticOperation(
		'getAllErrorBehaviorEvents', Sequence{self}
	);

helper context AADL2!Classifier def: errorStates(): Collection(EMV2!ErrorBehaviorState) =
	"#native"!"org::osate::xtext::aadl2::errormodel::util::EMV2Util".refInvokeStaticOperation(
		'getAllErrorBehaviorStates', Sequence{self}
	);

helper context AADL2!Classifier def: errorTransitions(): Collection(EMV2!ErrorBehaviorTransition) =
	"#native"!"org::osate::xtext::aadl2::errormodel::util::EMV2Util".refInvokeStaticOperation(
		'getAllErrorBehaviorTransitions', Sequence{self}
	);

helper context AADL2!Classifier def: outgoingPropagationConditions(): Collection(EMV2!OutgoingPropagationCondition) =
	"#native"!"org::osate::xtext::aadl2::errormodel::util::EMV2Util".refInvokeStaticOperation(
		'getAllOutgoingPropagationConditions', Sequence{self}
	);

helper context AADL!ComponentInstance def: outProp2propConds: Map(EMV2!ErrorPropagation, Set(EMV2!OutgoingPropagationCondition)) =
	self.classifier.outgoingPropagationConditions()->mappedBy(pc | pc.outgoing);

helper context AADL!ComponentInstance def: occurrenceDistribution(event:EMV2!ErrorBehaviorEvent): TupleType(name: String, lambda: Real) =
	let pas: Sequence(EMV2!EMV2PropertyAssociation) = 
			"#native"!"org::osate::xtext::aadl2::errormodel::util::EMV2Properties".refInvokeStaticOperation(
				'getOccurrenceDistributionProperty', Sequence{self, event, OclUndefined}
			) in
	if pas->isEmpty() then
		Tuple{name = '', lambda = 0.0}
 	else
 		let pa: EMV2!EMV2PropertyAssociation = pas->at(1) in
		Tuple{name = pa.occurrenceName(), lambda = pa.occurrenceValue()}
 	endif;

helper context EMV2!EMV2PropertyAssociation def: occurrenceName(): String =
	"#native"!"org::osate::xtext::aadl2::errormodel::util::EMV2Properties".refInvokeStaticOperation(
		'getOccurrenceType', Sequence{self}
	);
	
helper context EMV2!EMV2PropertyAssociation def: occurrenceValue(): Real =
	"#native"!"org::osate::xtext::aadl2::errormodel::util::EMV2Properties".refInvokeStaticOperation(
		'getOccurrenceValue', Sequence{self}
	);
	
helper context EMV2!ErrorPropagation def: name(): String =
	"#native"!"org::osate::xtext::aadl2::errormodel::util::EMV2Util".refInvokeStaticOperation(
		'getPropagationName', Sequence{self}
	);

helper context AADL2!NamedElement def: name(): String =
	self.getName();

helper context AADL2!Element def: containingClassifier(): AADL2!ComponentClassifier =
	"#native"!"org::osate::xtext::aadl2::errormodel::util::EMV2Util".refInvokeStaticOperation(
		'getAssociatedClassifier', Sequence{self}
	);
	
--- Get the leaf error tokens associated with an error propagation
helper context EMV2!ErrorPropagation def: leafTokens(): Sequence(EMV2!TypeToken) =
	let usedTypes: Sequence(EMV2!ErrorModelLibrary) = self.containingClassifier().usedTypes() in
	self.typeSet.leafTypeTokens(usedTypes);

helper context EMV2!TypeToken def: name() : String =
	"#native"!"org::osate::xtext::aadl2::errormodel::util::EMV2Util".refInvokeStaticOperation(
		'getName', Sequence{self}
	);
	
helper context EMV2!TypeSet def: leafTypeTokens(useTypes: Sequence(EMV2!ErrorModelLibrary)): Sequence(EMV2!TypeToken) =
	"#native"!"org::osate::xtext::aadl2::errormodel::util::EM2TypeSetUtil".refInvokeStaticOperation(
		'generateAllLeafTypeTokens', Sequence{self, useTypes}
	);

helper context EMV2!ConditionExpression def: conditionElements: EMV2!ErrorPropagation =
	"#native"!"org::osate::xtext::aadl2::errormodel::util::EMV2Util".refInvokeStaticOperation(
		'getAllConditionElementsFromConditionExpression', Sequence{self}
	);

helper context EMV2!ConditionElement def: getErrorPropagation(): EMV2!ErrorPropagation =
	let ne: AADL2!NamedElement = self.namedElement in
	if ne.oclIsTypeOf(EMV2!ErrorPropagation) then
		ne
	else
		OclUndefined
	endif;

helper context EMV2!ConditionElement def: getErrorEvent(): EMV2!ErrorEvent =
	let ne: AADL2!NamedElement = self.namedElement in
	if ne.oclIsTypeOf(EMV2!ErrorEvent) then
		ne
	else
		OclUndefined
	endif;

helper context EMV2!ConditionElement def: namedElement: AADL2!NamedElement =
	"#native"!"org::osate::xtext::aadl2::errormodel::util::EMV2Util".refInvokeStaticOperation(
		'getErrorModelElement', Sequence{self}
	);

helper context EMV2!ConditionElement def: isNoErrorCondition(): Boolean =
	if self.constraint.oclIsUndefined() then
		false
	else
		let tokens: Sequence(EMV2!TypeToken) = self.constraint.typeTokens in
		not tokens->isEmpty() and tokens->at(1).noError
	endif;

helper context EMV2!ConditionElement def: leafTokens(): Sequence(EMV2!TypeToken) =
	let usedTypes: Sequence(EMV2!ErrorModelLibrary) = self.containingClassifier().usedTypes() in
	if self.constraint.oclIsUndefined() then
		Sequence{}
	else
		self.constraint.leafTypeTokens(usedTypes)
	endif;

helper context EMV2!EMV2Path def: errorPropagation: EMV2!ErrorPropagation =
	"#native"!"org::osate::xtext::aadl2::errormodel::util::EMV2Util".refInvokeStaticOperation(
		'getErrorPropagation', Sequence{self}
	);

helper def: analysisModel: "#native"!"org::osate::xtext::aadl2::errormodel::util::AnalysisModel" =
	let si: AADL!SystemInstance = AADL!SystemInstance.allInstances() -> asSequence() -> first() in
		"#native"!"org::osate::xtext::aadl2::errormodel::util::AnalysisModel".refInvokeStaticOperation(
			'createAnalysisModel', Sequence{si});

-- Component instances that should be processed (leaf components wrt error model)
helper def: emLeafComponents: Sequence(AADL!ComponentInstance) = 
	thisModule.analysisModel.getSubcomponents();

helper def: propagationPaths: Sequence("#native"!"org::osate::xtext::aadl2::errormodel::util::PropagationPathRecord") =
	thisModule.analysisModel.getPropagationPaths();

-- How to split propagation destinations based on fan-in
helper def: dst2paths: Map(TupleType(io: AADL!ComponentInstance, prop: EMV2!ErrorPropagation), Sequence("#native"!"org::osate::xtext::aadl2::errormodel::util::PropagationPathRecord")) =
	thisModule.propagationPaths -> mappedBy(p | 
			let d: OclAny = p.getPathDst() in 
			Tuple{io = d.getComponentInstance(), prop = d.getErrorPropagation()}
	);

-- Where to put assertions
helper def: ci2paths: Map(AADL!ComponentInstance, Sequence("#native"!"org::osate::xtext::aadl2::errormodel::util::PropagationPathRecord")) =
	thisModule.propagationPaths -> mappedBy(p | p.assertionContainer);

helper context "#native"!"org::osate::xtext::aadl2::errormodel::util::PropagationPathRecord" def: assertionContainer: AADL!ComponentInstance =
	if self.isConnectionPath() then
		self.getConnectionInstance().eContainer()
	else
		thisModule.systemInstance
	endif;
	
helper def: systemInstance: AADL!SystemInstance = AADL!SystemInstance.allInstances() -> first();

-- Force evaluation of a lazy collection by getting its size
helper context Collection(OclAny) def: force(): Collection(OclAny) =
	let i: Integer = self.size() in self;

helper context Sequence(OclAny) def: tail(): Sequence(OclAny) =
	self.subSequence(2, self -> size());

--- Remove all elements of a sequence from this sequence
helper context Sequence(OclAny) def: removeAll(toRemove: Sequence(OclAny)): Sequence(OclAny) =
	if toRemove.isEmpty() then
		self
	else
		self->excluding(toRemove->first())->removeAll(toRemove->tail())
	endif;

-- Replace invalid characters in identifier with '_'
helper context String def: normalizeId(): String =
	self.replaceAll('[:.]', '_');

helper context String def: quoted(): String =
	'"' + self + '"';

helper context AADL2!NamedElement def: indexedName(index: Integer): String =
	self.altaRicaName() + '_' + index.toString();

helper context AADL2!NamedElement def: altaRicaName(): String =
	self.name().normalizeId();

helper context EMV2!ErrorPropagation def: altaRicaName(): String =
	let ref: EMV2!FeatureorPPReference = self.featureorPPRef in
	if ref.oclIsUndefined() then
		super.altaRicaName()
	else
		ref.altaRicaName()
	endif;

helper context EMV2!FeatureorPPReference def: altaRicaName(): String =
	let name: String = self.featureorPP.name in
	if self.next.oclIsUndefined() then 
		name
	else
		name + '_' + self.next.altaRicaName()
	endif;

helper def: int: AR!BaseTypeEnum = #"Integer";
