-- @atlcompiler emftvm
-- @nsURI AR=http://osate.org/Altarica/2.1
-- @nsURI AADL=http://aadl.info/AADL/2.0/instance
-- @nsURI AADL2=http://aadl.info/AADL/2.0
-- @nsURI EMV2=http://www.aadl.info/EMV2


module AADLEM2AltaRica;
create OUT: AR from IN: AADL;

-- Nodes must be declared before use
rule SystemInstance {
	from
		si: AADL!SystemInstance
	to
		s: AR!Model (
		)
	do {
		thisModule.MakeNode(si.componentClassifier, si);
		s.declarations <- thisModule.createdClasses;
		thisModule.analysisModel.printPropagationPaths();
		'done'.debug();
	}
}

-- Create a node for the referenced classifier
lazy rule MakeNode {
	from
		c: AADL2!ComponentClassifier,
	  ci: AADL!ComponentInstance (
	  	not thisModule.processedClassifiers -> contains(c)
	  )
  using {
		n: AR!Node = thisModule.Node(c);
		declarations: Sequence(AR!Declaration) = Sequence{};
		subs: Sequence(AADL!ComponentInstance) = ci.componentInstance;
		eps: Sequence(EMV2!ErrorPropagation) = c.errorPropagations();
  }
	do {
		-- fill in sub nodes
		if (not thisModule.emLeafComponents -> contains(ci) and not subs.isEmpty()) {
			declarations <- declarations -> append(thisModule.subNodes(subs));
		}
		-- fill in flow variables
		if (not eps.isEmpty()) {
			declarations <- declarations -> append(c.flows());
		}
		n.declarations <- declarations -> flatten();

		if (ci.oclIsTypeOf(AADL!SystemInstance)) {
			n.assertions <- thisModule.assertions();
		}
		thisModule.createdClasses <:= thisModule.createdClasses -> append(n);
		-- process each referenced classifier only once
		thisModule.processedClassifiers <:= thisModule.processedClassifiers -> including(c);
		n;
	}
}

helper def: processedClassifiers: Set(AADL2!ComponentClassifier) = Set{};

helper def: createdClasses: Sequence(AR!Node) = Sequence{};

-- Need this a a separate rule to resolve classifier
unique lazy rule Node {
	from	
		c: AADL2!ComponentClassifier
	to
		node: AR!Node (
			-- AltaRica editor doesn't understand quoted IDs
			-- name <- c.qualifiedName().quoted()
			name <- c.qualifiedName().normalizeId()
		)
}

-- The contained instances
helper def: subNodes(subs: Sequence(AADL!ComponentInstance)): Sequence(AR!Variable) =
	subs -> collect(s | thisModule.NodeInstance(s));

unique lazy rule NodeInstance {
	from
		ci: AADL!ComponentInstance
	to
		ni: AR!Variable (
			type <-
					let c: AADL2!ComponentClassifier = ci.componentClassifier in
					let referenced: AR!Node = 
							if thisModule.processedClassifiers -> contains(c) then
								thisModule.Node(c)
							else
								thisModule.MakeNode(c, ci)
							endif
					in
						thisModule.ClassType(referenced),
			name <- ci.name
		)
}

lazy rule ClassType {
	from
		node: AR!Node
	to
	  type: AR!ClassType (
	  	class <- node
		)
}

-- flow variables
helper context AADL2!ComponentClassifier def: flows(): Sequence(AR!Variable) =
	self.errorPropagations() -> collect(ep | thisModule.Flow(ep));

unique lazy rule Flow {
	from
		propagation: EMV2!ErrorPropagation
	to
		f: AR!Variable (
			type <- thisModule.BaseType(thisModule.int),
			name <- propagation.getFeatureorPPRef().altaRicaName()
		)
}

-- a bool or integer
lazy rule BaseType {
	from
		kind: AR!BaseTypeEnum
	to
	  p: AR!BaseType (
	  	name <- kind
		)
}

-- assertions (at top level)

helper def: assertions(): Sequence(AR!Instruction) =
	thisModule.propagationPaths -> 
			select(pp | pp.isConnectionPath()) -> 
			collect(pp | pp.makeAssertion());

helper context "#native"!"org::osate::xtext::aadl2::errormodel::util::PropagationPathRecord" def: makeAssertion(): AR!Instruction =
	let srcFlow: AR!NamedElement = thisModule.Flow(self.getPathSrc().getErrorPropagation()) in
	let dstFlow: AR!NamedElement = thisModule.Flow(self.getPathDst().getErrorPropagation()) in
	let srcCi: AADL!ComponentInstance = self.getPathSrc().getComponentInstance() in
	let dstCi: AADL!ComponentInstance = self.getPathDst().getComponentInstance() in
		thisModule.Assignment(thisModule.NameRef(dstFlow).makeNameRef(dstCi), thisModule.NameRef(srcFlow).makeNameRef(srcCi));

helper context AR!NameRef def: makeNameRef(owner: AADL!InstanceObject): AR!NameRef =
		if owner.oclIsTypeOf(AADL!SystemInstance) then
			self
		else
			let parent: AADL!InstanceObject = owner.refImmediateComposite() in
				thisModule.NestedRef(thisModule.NodeInstance(owner), self).makeNameRef(parent)
		endif;
	
lazy rule NestedRef {
	from
		owner: AR!Variable,
		nested: AR!NameRef
	to
		ref: AR!NestedRef (
			target <- thisModule.NameRef(owner),
			nested <- nested
		)
}

lazy rule NameRef {
	from
		element: AR!NamedElement
	to
		name: AR!NameRef (
			variable <- element
		)
}

lazy rule Assignment {
	from
		variable: AR!NameRef,
		value: AR!NameRef
	to
		i: AR!Assignment (
			variable <- variable,
			value <- value
		)
}

-- Replace invalid characters in identifier with '_'
helper context String def: normalizeId(): String =
	self.replaceAll('[:.]', '_');

helper context String def: quoted(): String =
	'"' + self + '"';

-- The component classifier for a compoent instance
helper context AADL!ComponentInstance def: componentClassifier: AADL2!ComponentClassifier =
	"#native"!"org::osate::aadl2::instance::util::InstanceUtil".refInvokeStaticOperation(
		'getComponentClassifier', Sequence{self, 0, OclUndefined}
	);

-- Helpers for EMV2 processing
helper context AADL2!Classifier def: outgoingErrorPropagations(): Sequence(EMV2!ErrorPropagation) =
	"#native"!"org::osate::xtext::aadl2::errormodel::util::EMV2Util".refInvokeStaticOperation(
		'getAllOutgoingErrorPropagations', Sequence{self}
	);

helper context AADL2!Classifier def: incomingErrorPropagations(): Sequence(EMV2!ErrorPropagation) =
	"#native"!"org::osate::xtext::aadl2::errormodel::util::EMV2Util".refInvokeStaticOperation(
		'getAllIncomingErrorPropagations', Sequence{self}
	);

helper context AADL2!Classifier def: errorPropagations(): Sequence(EMV2!ErrorPropagation) =
	self.incomingErrorPropagations() -> including(self.outgoingErrorPropagations()) -> flatten();

helper context AADL2!Classifier def: usedTypes(): Sequence(EMV2!ErrorModelLibrary) =
	"#native"!"org::osate::xtext::aadl2::errormodel::util::EMV2Util".refInvokeStaticOperation(
		'getErrorModelSubclauseWithUseTypes', Sequence{self}
	);

helper context EMV2!ErrorPropagation def: altaRicaName(): String =
	let
		ref: EMV2!FeatureorPPReference = self.getFeatureorPPRef()
	in
		ref.altaRicaName();

helper context EMV2!FeatureorPPReference def: altaRicaName(): String =
	let
		name: String = self.featureorPP.name
	in
		if self.next.oclIsUndefined() then name else name + '_' + self.next.altaRicaName() endif;

helper context EMV2!TypeSet def: leafTypeTokens(useTypes: Sequence(EMV2!ErrorModelLibrary)): Sequence(EMV2!TypeToken) =
	"#native"!"org::osate::xtext::aadl2::errormodel::util::EM2TypeSetUtil".refInvokeStaticOperation(
		'generateAllLeafTypeTokens', Sequence{self, useTypes}
	);

helper def: analysisModel: "#native"!"org::osate::xtext::aadl2::errormodel::util::AnalysisModel" =
	let si: AADL!SystemInstance = AADL!SystemInstance.allInstances() -> asSequence() -> first() in
		"#native"!"org::osate::xtext::aadl2::errormodel::util::AnalysisModel".refInvokeStaticOperation('createAnalysisModel', Sequence{si});

-- Component instances that should be processed (leaf components wrt error model)
helper def: emLeafComponents: Sequence(AADL!ComponentInstance) = 
	thisModule.analysisModel.getSubcomponents();

helper def: propagationPaths: Sequence("#native"!"org::osate::xtext::aadl2::errormodel::util::PropagationPathRecord") =
	thisModule.analysisModel.getPropagationPaths();

-- Force evaluation of a lazy collection by getting its size
helper context Collection(OclAny) def: force(): Collection(OclAny) =
	let i: Integer = self.size() in self;

helper def: int: AR!BaseTypeEnum = #"Integer";
