-- @atlcompiler emftvm
-- @nsURI AR=http://osate.org/Altarica/2.1
-- @nsURI AADL=http://aadl.info/AADL/2.0/instance
-- @nsURI AADL2=http://aadl.info/AADL/2.0
-- @nsURI EMV2=http://www.aadl.info/EMV2


module AADLEM2AltaRica;
create OUT: AR from IN: AADL;

uses Util;

-- Nodes must be declared before use
rule SystemInstance {
	from
		si: AADL!SystemInstance
	to
		m: AR!Model (
		)
	do {
		thisModule.Node(si);
	}
}

endpoint rule Finish() {
	using {
		m: AR!Model = thisModule.traces.getDefaultSourceElements()
			-> collect(e | e.getObject())
			-> any(o | o.oclIsKindOf(AADL!SystemInstance)).resolve();
	}
	do {
		m.declarations <- thisModule.createdClasses -> reverse();
		thisModule.analysisModel.printPropagationPaths();
		'done'.debug();
	}
}

helper def: createdClasses: Sequence(AR!Node) = Sequence{};

unique lazy rule Node {
	from	
		ci: AADL!ComponentInstance
  using {
		c: AADL2!ComponentClassifier = ci.componentClassifier;
		hasPropagations: Sequence(EMV2!ErrorPropagation) = 
			not (c.oclIsUndefined() or c.errorPropagations().isEmpty());
  }
	to
		node: AR!Node (
			name <- ((c.name + '__' + ci.debug().getQualifiedName()).normalizeId() + '_' + thisModule.createdClasses -> size().toString()).debug(' as '),
			declarations <- ci.subnodes() -> append(ci.flows()) -> flatten(),
			assertions <- ci.assertions()
		)
	do {
		thisModule.createdClasses <:= thisModule.createdClasses -> append(node);
		node;
	}
}

-- the contained node instances
helper context AADL!ComponentInstance def: subnodes(): Sequence(AR!Variable) =
	if self.isLeaf then Sequence{}
	else self.componentInstance -> collect(sub | sub.nodeInstance) endif;

-- the node instance in AltaRica corresponding to this component instance in AADL
helper context AADL!ComponentInstance def: nodeInstance: AR!Variable = thisModule.NodeInstance(self);

unique lazy rule NodeInstance {
	from
		sub: AADL!ComponentInstance
	to
		ni: AR!Variable (
			name <- sub.name.debug('Node instance in ' + sub.eContainer().name),
			type <- classType 
		),
	  classType: AR!ClassType (
	  	class <- thisModule.Node(sub)
		)
}

-- flow variables

helper context AADL!ComponentInstance def: flows(): Sequence(AR!Variable) =
	self.componentClassifier.errorPropagations() -> collect(ep | thisModule.Flow(self, ep));

unique lazy rule Flow {
	from
		ci: AADL!ComponentInstance,
		propagation: EMV2!ErrorPropagation
	to
		f: AR!Variable (
			type <- thisModule.BaseType(thisModule.int),
			name <- propagation.getFeatureorPPRef().altaRicaName().debug('variable: ')
		)
}

-- a bool or integer

lazy rule BaseType {
	from
		kind: AR!BaseTypeEnum
	to
	  p: AR!BaseType (
	  	name <- kind
		)
}

-- external assertions (at top level)

helper context AADL!ComponentInstance def: assertions(): Sequence(AR!Instruction) =
	if self.oclIsTypeOf(AADL!SystemInstance) then
		thisModule.propagationPaths -> 
				select(pp | not pp.isConnectionBindingPath()) -> 
				collect(pp | pp.makeAssertion())
	else
		Sequence{}
	endif;

helper context "#native"!"org::osate::xtext::aadl2::errormodel::util::PropagationPathRecord" 
		def: makeAssertion(): AR!Instruction =
	let srcCi: AADL!ComponentInstance = self.getPathSrc().getComponentInstance() in
	let dstCi: AADL!ComponentInstance = self.getPathDst().getComponentInstance() in
	let srcFlow: AR!Variable = thisModule.Flow(srcCi, self.getPathSrc().getErrorPropagation()) in
	let dstFlow: AR!Variable = thisModule.Flow(dstCi, self.getPathDst().getErrorPropagation()) in
	thisModule.Assignment(thisModule.NameRef(dstFlow, dstCi), thisModule.NameRef(srcFlow, srcCi));

lazy rule Assignment {
	from
		variable: AR!NameRef,
		value: AR!NameRef
	to
		i: AR!Assignment (
			variable <- variable,
			value <- value
		)
}
	
lazy rule NameRef {
	from
		var: AR!Variable,
		owner: AADL!ComponentInstance
	to
		ref: AR!NameRef (
			variable <- var.debug(),
			nested <- 
					let parent: AADL!ComponentInstance = owner.refImmediateComposite() in
					if parent.oclIsTypeOf(AADL!SystemInstance) then		
						thisModule.LeafNameRef(owner.nodeInstance)
					else
						thisModule.NameRef(owner.nodeInstance, parent)
					endif
		)
}

lazy rule LeafNameRef {
	from
		var: AR!Variable
	to
		ref: AR!NameRef (
			variable <- var.debug()
		)
}

