-- @atlcompiler emftvm
-- @nsURI AR=http://osate.org/Altarica/2.1
-- @nsURI AADL=http://aadl.info/AADL/2.0/instance
-- @nsURI AADL2=http://aadl.info/AADL/2.0
-- @nsURI EMV2=http://www.aadl.info/EMV2


module AADLEM2AltaRica;
create OUT: AR from IN: AADL;

uses Util;

-- Nodes must be declared before use
rule SystemInstance {
	from
		si: AADL!SystemInstance
	to
		m: AR!Model (
		)
	do {
		thisModule.MakeNode(si.componentClassifier, si);
	}
}

endpoint rule Finish() {
	using {
		m: AR!Model = thisModule.traces.getDefaultSourceElements()
			-> collect(e | e.getObject())
			-> any(o | o.oclIsKindOf(AADL!SystemInstance)).resolve();
	}
	do {
		m.declarations <- thisModule.createdClasses -> reverse();
		thisModule.analysisModel.printPropagationPaths();
		'done'.debug();
	}
}

-- Create a node for the referenced classifier
lazy rule MakeNode {
	from
		c: AADL2!ComponentClassifier,
	  ci: AADL!ComponentInstance (
	  	not thisModule.processedClassifiers -> contains(c)
	  )
  using {
		n: AR!Node = thisModule.Node(c);
		declarations: Sequence(AR!Declaration) = Sequence{};
		subs: Sequence(AADL!ComponentInstance) = ci.componentInstance;
		eps: Sequence(EMV2!ErrorPropagation) = c.errorPropagations();
		m: AR!Node = n;
  }
	do {
		-- fill in sub nodes
		if (not thisModule.emLeafComponents -> contains(ci) and not subs.isEmpty()) {
			declarations <- declarations -> append(thisModule.subNodes(subs));
		}
		-- fill in flow variables
		if (not eps.isEmpty()) {
			declarations <- declarations -> append(c.flows());
		}
		n.declarations <- declarations -> flatten();

		if (ci.oclIsTypeOf(AADL!SystemInstance)) {
			n.assertions <- thisModule.assertions();
		}
		thisModule.createdClasses <:= thisModule.createdClasses -> append(n);
		-- process each referenced classifier only once
		thisModule.processedClassifiers <:= thisModule.processedClassifiers -> including(c);
		m;
	}
}

helper def: processedClassifiers: Set(AADL2!ComponentClassifier) = Set{};

helper def: createdClasses: Sequence(AR!Node) = Sequence{};

-- Need this a a separate rule to resolve classifier
unique lazy rule Node {
	from	
		c: AADL2!ComponentClassifier
	to
		node: AR!Node (
			name <- c.debug().getQualifiedName().debug().normalizeId()
		)
}

-- The contained instances
helper def: subNodes(subs: Sequence(AADL!ComponentInstance)): Sequence(AR!Variable) =
	subs -> collect(s | thisModule.NodeInstance(s));

unique lazy rule NodeInstance {
	from
		ci: AADL!ComponentInstance
	to
		ni: AR!Variable (
			type <-
					let c: AADL2!ComponentClassifier = ci.componentClassifier in
					let referenced: AR!Node = 
							if thisModule.processedClassifiers -> contains(c) then
								thisModule.Node(c)
							else
								thisModule.MakeNode(c, ci)
							endif
					in
						thisModule.ClassType(referenced),
			name <- ci.name
		)
}

lazy rule ClassType {
	from
		node: AR!Node
	to
	  type: AR!ClassType (
	  	class <- node
		)
}

-- flow variables
helper context AADL2!ComponentClassifier def: flows(): Sequence(AR!Variable) =
	self.errorPropagations() -> collect(ep | thisModule.Flow(ep));

unique lazy rule Flow {
	from
		propagation: EMV2!ErrorPropagation
	to
		f: AR!Variable (
			type <- thisModule.BaseType(thisModule.int),
			name <- propagation.getFeatureorPPRef().altaRicaName()
		)
}

-- a bool or integer
lazy rule BaseType {
	from
		kind: AR!BaseTypeEnum
	to
	  p: AR!BaseType (
	  	name <- kind
		)
}

-- assertions (at top level)

helper def: assertions(): Sequence(AR!Instruction) =
	thisModule.propagationPaths -> 
			select(pp | pp.isConnectionPath()) -> 
			collect(pp | pp.makeAssertion());

helper context "#native"!"org::osate::xtext::aadl2::errormodel::util::PropagationPathRecord" def: makeAssertion(): AR!Instruction =
	let srcFlow: AR!NamedElement = thisModule.Flow(self.getPathSrc().getErrorPropagation()) in
	let dstFlow: AR!NamedElement = thisModule.Flow(self.getPathDst().getErrorPropagation()) in
	let srcCi: AADL!ComponentInstance = self.getPathSrc().getComponentInstance() in
	let dstCi: AADL!ComponentInstance = self.getPathDst().getComponentInstance() in
		thisModule.Assignment(thisModule.NameRef(dstFlow).makeNameRef(dstCi), thisModule.NameRef(srcFlow).makeNameRef(srcCi));

helper context AR!NameRef def: makeNameRef(owner: AADL!InstanceObject): AR!NameRef =
		if owner.oclIsTypeOf(AADL!SystemInstance) then
			self
		else
			let parent: AADL!InstanceObject = owner.refImmediateComposite() in
				thisModule.NestedRef(thisModule.NodeInstance(owner), self).makeNameRef(parent)
		endif;
	
lazy rule NestedRef {
	from
		owner: AR!Variable,
		nested: AR!NameRef
	to
		ref: AR!NestedRef (
			target <- thisModule.NameRef(owner),
			nested <- nested
		)
}

lazy rule NameRef {
	from
		element: AR!NamedElement
	to
		name: AR!NameRef (
			variable <- element
		)
}

lazy rule Assignment {
	from
		variable: AR!NameRef,
		value: AR!NameRef
	to
		i: AR!Assignment (
			variable <- variable,
			value <- value
		)
}

