-- @atlcompiler emftvm
-- @nsURI AR=http://osate.org/Altarica
-- @nsURI AADL=http://aadl.info/AADL/2.0/instance
-- @nsURI AADL2=http://aadl.info/AADL/2.0
-- @nsURI EMV2=http://www.aadl.info/EMV2


module AADLEM2AltaRica;
create OUT: AR from IN: AADL;

-- Nodes must be declared before use
rule SystemInstance {
	from
		si: AADL!SystemInstance
	using {
			emNodes: Sequence(AR!AbstractDeclaration) = thisModule.postOrder(si) 
					-> flatten()
					-> collect(ci | thisModule.makeNode(ci.componentClassifier(), ci))
					-> select(n | not n.oclIsUndefined()) -> force();
	}
	to
		s: AR!System (
			ownedDeclarations <- emNodes -> including(thisModule.makeTopNode(si))
		)
	do {
		thisModule.analysisModel.printPropagationPaths();
	}
}

-- Traverse instance model in post order
helper def: postOrder(ci: AADL!ComponentInstance): Sequence(AADL!ComponentInstance) =
	let
		subs: Sequence(AADL!ComponentInstance) = ci.componentInstance
	in
		subs -> iterate(sub; acc:Sequence(AADL!ComponentInstance) = Sequence{} |
				acc -> append(thisModule.postOrder(sub))
		).append(ci);

-- Create a node for the referenced classifier
-- This must be a rule because we need to modify the created node
lazy rule makeNode {
	from
		c: AADL2!ComponentClassifier,
	  ci: AADL!ComponentInstance (
	  	thisModule.emLeafComponents -> contains(ci) and
	  	not thisModule.processedClassifiers -> contains(c)
	  )
  using {
		n: AR!Node = thisModule.Node(c);
		specifications: Sequence(AR!AbstractSpecification) = Sequence{};
		eps: Sequence(EMV2!ErrorPropagation) = c.errorPropagations();
  }
	do {
		-- fill in flow variables
		if (not eps.isEmpty()) {
			specifications <- specifications -> including(thisModule.flows(c)) -> flatten();
		}
		-- fill in sub nodes
		--if (not ci.componentInstance.isEmpty()) {
		--	specifications <- specifications -> including(thisModule.subNodes(ci, ci.componentInstance)) -> flatten();
		--}
		n.ownedSpecifications <- specifications;
		-- process each referenced classifier only once
		thisModule.processedClassifiers <:= thisModule.processedClassifiers.including(c);
		n;
	}
}

lazy rule makeTopNode {
	from
		si: AADL!SystemInstance
	using {
		top: AR!Node = thisModule.Node(si.getComponentImplementation());
		specifications: Sequence(AR!AbstractSpecification) = Sequence{};
	}
	do {
		if (not thisModule.emLeafComponents.isEmpty()) {
			specifications <- specifications -> including(thisModule.subNodes(si, thisModule.emLeafComponents -> asSequence()));
		}
		top.ownedSpecifications <- specifications;
		top;
	}
}

helper def: processedClassifiers: Set(AADL2!ComponentClassifier) = Set{};

-- Need this a a separate rule to resolve classifier
-- Alternative is to create a (classifier |-> node) map
unique lazy rule Node {
	from	
		c: AADL2!ComponentClassifier
	to
		n: AR!Node (
			-- AltaRica editor doesn't understand quoted IDs
			-- name <- c.qualifiedName().quoted()
			name <- c.qualifiedName().normalizeId()
		)
}

-- The sub-nodes section
lazy rule subNodes {
	from
		ci: AADL!ComponentInstance,
		subs: Sequence(AADL!ComponentInstance)
	to
		nis: AR!NodeInstanceSpecification (
			ownedNodeInstances <- subs -> collect(s | thisModule.NodeInstance(s))
		)
}

lazy rule NodeInstance {
	from
		ci: AADL!ComponentInstance
	to
		ni: AR!NodeInstance (
			name <- ci.name,
			nodeType <- ci.componentClassifier().debug().resolve('Node')
		)
}

-- The flows section
lazy rule flows {
	from
		c: AADL!ComponentClassifier
	to
		nis: AR!FlowSpecification (
			ownedFlows <- 
					c.incomingErrorPropagations() -> collect(ep | c.makeFlows(ep, thisModule.flowDirectionIn))
					-> including(c.outgoingErrorPropagations() -> collect(ep | c.makeFlows(ep, thisModule.flowDirectionOut)))
					-> flatten()
		)
}

helper context AADL2!ComponentClassifier def: makeFlows(ep: EMV2!ErrorPropagation, dir: AR!FlowKind): Sequence(AR!Flow) =
	let
		tokens: Sequence(EMV2!TypeToken) = ep.getTypeSet().leafTypeTokens(self.usedTypes())
	in
		-- TODO: process all tokens
		tokens -> collect(t | thisModule.Flow(ep, t.type -> first().name, dir));
	
lazy rule Flow {
	from
		ep: EMV2!ErrorPropagation,
--		leafToken: EMV2!TypeToken,
		tokenName: String,
		dir: AR!FlowKind
	to
		f: AR!Flow (
			-- name <- ep.debug().altaRicaName(leafToken.debug().type -> first().name.debug()),
			name <- ep.altaRicaName(tokenName),
			domain <- thisModule.PrimitiveType(#bool),
			kind <- dir
		)
}

-- a bool or integer
lazy rule PrimitiveType {
	from
		kind: AR!PrimitiveTypeKind
	to
	  p: AR!PrimitiveType (
	  	name <- kind
		)
}

-- Replace invalid characters in identifier with '_'
helper context String def: normalizeId(): String =
	self.replaceAll('[:.]', '_');

helper context String def: quoted(): String =
	'"' + self + '"';

-- Get the component classifier for a compoent instance
helper context AADL!ComponentInstance def: componentClassifier(): AADL2!ComponentClassifier =
	"#native"!"org::osate::aadl2::instance::util::InstanceUtil".refInvokeStaticOperation(
		'getComponentClassifier', Sequence{self, 0, OclUndefined}
	);

-- Helpers for EMV2 processing
helper context AADL2!Classifier def: outgoingErrorPropagations(): Sequence(EMV2!ErrorPropagation) =
	"#native"!"org::osate::xtext::aadl2::errormodel::util::EMV2Util".refInvokeStaticOperation(
		'getAllOutgoingErrorPropagations', Sequence{self}
	);

helper context AADL2!Classifier def: incomingErrorPropagations(): Sequence(EMV2!ErrorPropagation) =
	"#native"!"org::osate::xtext::aadl2::errormodel::util::EMV2Util".refInvokeStaticOperation(
		'getAllIncomingErrorPropagations', Sequence{self}
	);

helper context AADL2!Classifier def: errorPropagations(): Sequence(EMV2!ErrorPropagation) =
	self.incomingErrorPropagations() -> including(self.outgoingErrorPropagations()) -> flatten();

helper context AADL2!Classifier def: usedTypes(): Sequence(EMV2!ErrorModelLibrary) =
	"#native"!"org::osate::xtext::aadl2::errormodel::util::EMV2Util".refInvokeStaticOperation(
		'getErrorModelSubclauseWithUseTypes', Sequence{self}
	);

helper context EMV2!ErrorPropagation def: altaRicaName(typeName: String): String =
	let
		ref: EMV2!FeatureorPPReference = self.getFeatureorPPRef()
	in
		ref.altaRicaName() + '_' + typeName;

helper context EMV2!FeatureorPPReference def: altaRicaName(): String =
	let
		name: String = self.featureorPP.name
	in
		if self.next.oclIsUndefined() then name else name + '_' + self.next.altaRicaName() endif;

helper context EMV2!TypeSet def: leafTypeTokens(useTypes: Sequence(EMV2!ErrorModelLibrary)): Sequence(EMV2!TypeToken) =
	"#native"!"org::osate::xtext::aadl2::errormodel::util::EM2TypeSetUtil".refInvokeStaticOperation(
		'generateAllLeafTypeTokens', Sequence{self, useTypes}
	);

helper def: analysisModel: "#native"!"org::osate::xtext::aadl2::errormodel::util::AnalysisModel" =
	let si: AADL!SystemInstance = AADL!SystemInstance.allInstances() -> asSequence() -> first() in
		"#native"!"org::osate::xtext::aadl2::errormodel::util::AnalysisModel".refInvokeStaticOperation('createAnalysisModel', Sequence{si});

-- Component instances that should be processed (leaf components wrt error model)
helper def: emLeafComponents: Sequence(AADL!ComponentInstance) = thisModule.analysisModel.getSubcomponents();

-- Force evaluation of a lazy collection by getting its size
helper context Collection(OclAny) def: force(): Collection(OclAny) =
	let i: Integer = self.size() in self;

helper def: flowDirectionOut: AR!FlowKind = #out;
helper def: flowDirectionIn: AR!FlowKind = #"in";


