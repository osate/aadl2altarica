-- @atlcompiler emftvm
-- @nsURI AR=http://osate.org/Altarica/2.1
-- @nsURI AADL=http://aadl.info/AADL/2.0/instance
-- @nsURI AADL2=http://aadl.info/AADL/2.0
-- @nsURI EMV2=http://www.aadl.info/EMV2


module AADLEM2AltaRica;
create OUT: AR from IN: AADL;

uses Util;

-- Nodes must be declared before use
rule SystemInstance {
	from
		si: AADL!SystemInstance
	to
		m: AR!Model (
		)
	do {
		thisModule.Node(si);
	}
}

-- helper to collect created domains
helper def: domains: Sequence(AR!Domain) = Sequence{};

-- helper to collect created classes
helper def: classes: Sequence(AR!Node) = Sequence{};

endpoint rule Finish() {
	using {
		m: AR!Model = thisModule.traces.getDefaultSourceElements()
			-> collect(e | e.getObject())
			-> any(o | o.oclIsKindOf(AADL!SystemInstance)).resolve();
	}
	do {
		m.declarations <- 
				thisModule.domains -> append(thisModule.classes) -> flatten();
--		thisModule.analysisModel.printPropagationPaths();
		'done'.debug();
	}
}

unique lazy rule Node {
	from	
		ci: AADL!ComponentInstance
  using {
		c: AADL2!ComponentClassifier = ci.classifier;
		hasPropagations: Sequence(EMV2!ErrorPropagation) = 
			not (c.oclIsUndefined() or c.errorPropagations().isEmpty());
  }
	to
		node: AR!Node (
			name <- c.name.normalizeId() + '_' + thisModule.classes -> size().toString(),
			-- need to force declarations because assertions need containment structure in place
			declarations <- ci.subnodes() -> force() ->
					append(ci.events()) -> append(ci.states()) -> append(ci.flows()) -> flatten(),
			transitions <- ci.transitions(),
			assertions <- ci.internalAssertions() -> append(ci.externalAssertions()) -> flatten()
		)
	do {
		thisModule.classes <:= thisModule.classes -> prepend(node);
		node;
	}
}

-- the contained node instances
helper context AADL!ComponentInstance def: subnodes(): Sequence(AR!Variable) =
	if self.isLeaf then Sequence{}
	else self.componentInstance -> collect(sub | sub.nodeInstance) endif;

-- the node instance in AltaRica corresponding to this component instance in AADL
helper context AADL!ComponentInstance def: nodeInstance: AR!Variable = thisModule.NodeInstance(self);

unique lazy rule NodeInstance {
	from
		sub: AADL!ComponentInstance
	to
		ni: AR!Variable (
			name <- sub.name,
			type <- classType 
		),
	  classType: AR!NamedType (
	  	ref <- thisModule.Node(sub)
		)
}

-- events
-- TODO: handle typed error events

helper context AADL!ComponentInstance def: events(): Sequence(AR!Variable) =
	let evs: Sequence(AR!Variable) = self.classifier.errorEvents() -> collect(event | thisModule.Event(self, event)) in
		if self.classifier.incomingErrorPropagations().isEmpty() then 
			evs 
		else 
			evs.append(thisModule.ImmediateEvent(self))
		endif;

unique lazy rule Event {
	from
		ci: AADL!ComponentInstance,
		e: EMV2!ErrorBehaviorEvent
	to
		event: AR!Event (
			name <- e.altaRicaName()
		)
}

unique lazy rule ImmediateEvent {
	from 
		ci: AADL!ComponentInstance
	to
		event: AR!Event (
			name <- 'error_propagation',
			attributes <- Sequence{delay}
		),
		delay: AR!Attribute (
			name <- 'delay',
			value <- zero
		),
		zero: AR!ARInteger (
			value <- 0
		)
}
-- states
-- TODO: handle typed error states

helper context AADL!ComponentInstance def: states(): Sequence(AR!Variable) =
	let state: AR!Variable = thisModule.State(self) in
	if state.oclIsUndefined() then 
		Sequence{}
	else 
		Sequence{state}
	endif;

unique lazy rule State {
	from
		ci: AADL!ComponentInstance (
			ci.classifier.errorStates() -> notEmpty()
		)
	to
		state: AR!Variable (
			name <- 'errorstate',
			type <- thisModule.StateDomainType(ci),
			attributes <- Sequence{init}
		),
		init: AR!Attribute (
			name <- 'init',
			value <- ci.classifier.initialState().ref()
		)
}

--- Get the initial error state
helper context AADL2!ComponentClassifier def: initialState(): AR!SymbolicConstant =
	let state: EMV2!ErrorBehaviorState = self.errorStates() -> any(s | s.isInitial()) in
	thisModule.StateSymbol(self, state);

--- Workaround for typo in EMV2 grammar
helper context EMV2!ErrorBehaviorState def: isInitial(): Boolean = self.isIntial();

lazy rule StateDomainType {
	from
		ci: AADL!ComponentInstance
	to
		domainType: AR!NamedType (
			ref <- thisModule.StateDomain(ci.classifier)
		)
}

-- map to keep track of type tokens in domains
--helper def: domain2tokens: Map(AR!Domain, Set(EMV2!TypeToken)) = Map{};

--- doc
unique lazy rule StateDomain {
	from
		c: AADL!ComponentClassifier
	using {
		count: Integer = thisModule.domainCount;
	}
	to
		domain: AR!Domain (
			name <- 'domain_' + count.toString(),
			constants <- c.createSymbols()
		)
	do {
		thisModule.domainCount <:= count + 1;
		thisModule.domains <:= thisModule.domains -> append(domain);
		domain;
	}
}
	
--- Create the symbols for the domain of the error propagation
helper context AADL2!ComponentClassifier def: createSymbols(): Sequence(AR!SymbolicConstant) =
	self.errorStates() -> collect(s | thisModule.StateSymbol(self, s));

unique lazy rule StateSymbol {
	from
		c: AADL2!ComponentClassifier,
		state: EMV2!ErrorBehaviorState
	to 
		const: AR!SymbolicConstant (
			name <- state.altaRicaName()
		)
}

-- flow variables

helper context AADL!ComponentInstance def: flows(): Sequence(AR!Variable) =
	let outFlows: Sequence(AR!Variable) = 
		self.classifier.outgoingErrorPropagations() -> collect(oep | thisModule.OutFlow(self, oep)) in
	let inFlows: Sequence(AR!Variable) = 
		self.classifier.incomingErrorPropagations() ->
				collect(iep | thisModule.dst2paths.get(Tuple{io = self, prop = iep}) -> collect(path | thisModule.InFlow(self, path))) in
	outFlows -> append(inFlows);

--- Map to keep track of flow variables created for propagations in a component instance
helper def: ep2flows: Map(TupleType(io: AADL!ComponentInstance, prop: EMV2!ErrorPropagation), Sequence(AR!Variable)) = Map{};

unique lazy rule OutFlow {
	from
		ci: AADL!ComponentInstance,
		prop: EMV2!ErrorPropagation
	to
		flow: AR!Variable (
			name <- prop.altaRicaName(),
			type <- thisModule.FlowDomainType(prop),
			attributes <- Sequence{reset}
		),
		reset: AR!Attribute (
			name <- 'reset',
			value <- prop.noError.ref()
		)
	do {
		thisModule.ep2flows <:= thisModule.ep2flows -> 
				including(Tuple{io = ci, prop = prop}, Sequence{flow});
		flow;
	}
}

--- Return the no_error symbol for this out(!) propagation
helper context EMV2!ErrorPropagation def: noError: AR!SymbolicConstant =
	thisModule.NoError(thisModule.FlowDomain(self));

--- Return the no_error symbol for this in(!) flow
helper context AR!Variable def: noError: AR!SymbolicConstant =
	let srcProp: EMV2!ErrorPropagation = thisModule.inFlow2srcProp.get(self) in
	srcProp.noError;

--- Return the symbolic constant corresponding to the given token for this in(!) flow
helper context AR!Variable def: constant(token: EMV2!TypeToken): AR!SymbolicConstant =
	let srcProp: EMV2!ErrorPropagation = thisModule.inFlow2srcProp.get(self) in
	srcProp.getSymbol(token);

--- Map to keep track of propagations used to create the domain for incoming flow variables
helper def: inFlow2srcProp: Map(AR!Variable, EMV2!ErrorPropagation) = Map{};

unique lazy rule InFlow {
	from
		ci: AADL!ComponentInstance,
		path: "#native"!"org::osate::xtext::aadl2::errormodel::util::PropagationPathRecord"
	using {
		count: Integer = thisModule.inCount;
		prop: EMV2!ErrorPropagation = path.getPathDst().getErrorPropagation();
		srcProp: EMV2!ErrorPropagation = path.getPathSrc().getErrorPropagation();
	}
	to
		flow: AR!Variable (
			name <- prop.indexedName(count),
			type <- thisModule.FlowDomainType(srcProp)
		)
	do {
		if (thisModule.ep2flows.getKeys() -> includes(Tuple{io = ci, prop = prop})) {
			thisModule.ep2flows <:= thisModule.ep2flows -> 
					including(
							Tuple{io = ci, prop = prop}, 
							thisModule.ep2flows.get(Tuple{io = ci, prop = prop}) -> append(flow)
					);
		} else {
			thisModule.ep2flows <:= thisModule.ep2flows -> 
					including(Tuple{io = ci, prop = prop}, Sequence{flow});
		}
		thisModule.inFlow2srcProp <:= thisModule.inFlow2srcProp -> including(flow, srcProp);
		thisModule.inCount <:= count + 1;
		flow;
	}
}
-- counter for in flow variable names to avoid duplicates
helper def: inCount: Integer = 0;

lazy rule FlowDomainType {
	from
		prop: EMV2!ErrorPropagation
	to
		domainType: AR!NamedType (
			ref <- thisModule.FlowDomain(prop)
		)
}

--- doc
unique lazy rule FlowDomain {
	from
		prop: EMV2!ErrorPropagation
	using {
		count: Integer = thisModule.domainCount;
	}
	to
		domain: AR!Domain (
			name <- 'domain_' + count.toString(),
			constants <- prop.createSymbols() -> prepend(thisModule.NoError(domain))
		)
	do {
		thisModule.domainCount <:= count + 1;
		thisModule.domains <:= thisModule.domains -> append(domain);
		domain;
	}
}

helper def: domainCount: Integer = 0;

--- Create the symbols for the domain of the error propagation
helper context EMV2!ErrorPropagation def: createSymbols(): Sequence(AR!SymbolicConstant) =
	self.leafTokens() -> collect(t | self.getSymbol(t));
	
helper context EMV2!ErrorPropagation def: getSymbol(token: EMV2!TypeToken): AR!SymbolicConstant =
	thisModule.SymbolicConstant(self, token.name());
	
unique lazy rule SymbolicConstant {
	from
		prop: EMV2!ErrorPropagation,
		name: String
	to 
		const: AR!SymbolicConstant (
			name <- name
		)
}

unique lazy rule NoError {
	from 
		domain: AR!Domain
	to
		noError: AR!SymbolicConstant (
			name <- 'no_error'
		)
}

-- transitions

helper context EMV2!ConditionExpression def: isSingleEvent(): Boolean =
	self.oclIsTypeOf(EMV2!ConditionElement) and self.constraint.oclIsUndefined() and self.qualifiedErrorPropagationReference.emv2Target.namedElement.oclIsTypeOf(EMV2!ErrorEvent);

helper context AADL!ComponentInstance def: transitions(): Sequence(AR!LabeledTransition) =
	let transitions: Collection(EMV2!ErrorBehaviorTransition) = self.classifier.errorTransitions() in
	let handled_events: Collection(EMV2!ErrorBehaviorTransition) = 
		transitions -> select(t |
			not (t.source.oclIsUndefined() or t.target.oclIsUndefined()) and t.condition.isSingleEvent()
		) in
	let handled_props: Collection(EMV2!ErrorBehaviorTransition) =
		transitions -> select(t |
			not (t.source.oclIsUndefined() or t.target.oclIsUndefined()) and not t.condition.isSingleEvent()
		)
	in
		handled_events -> collect(t | thisModule.EventTransition(self, t))
		-> append(handled_props -> collect(t | thisModule.PropagationTransition(self, t)))
		-> flatten()
	;

--- Create a transition which is caused by an event
lazy rule EventTransition {
	from
		ci: AADL!ComponentInstance,
		et: EMV2!ErrorBehaviorTransition
	to
		lt: AR!LabeledTransition (
			event <- let event: AR!Event = thisModule.Event(ci, et.condition.qualifiedErrorPropagationReference.emv2Target.namedElement) in
					event.ref(),
			expression <- te
		),
		te: AR!Transition (
			guard <- thisModule.Equal(thisModule.State(ci), thisModule.StateSymbol(ci.classifier, et.source)),
			action <- a
		),
		a: AR!Assignment (
			variable <- thisModule.State(ci).ref(),
			value <- thisModule.StateSymbol(ci.classifier, et.target).ref()
		)
}


--- Create a state transition which is caused by an incoming error propagation
lazy rule PropagationTransition {
	from
		ci: AADL!ComponentInstance,
		et: EMV2!ErrorBehaviorTransition
	to
		lt: AR!LabeledTransition (
			event <- thisModule.ImmediateEvent(ci).ref(),
			expression <- te
		),
		te: AR!Transition (
			guard <- ci.guardExpression(et),
			action <- a
		),
		a: AR!Assignment (
			variable <- thisModule.State(ci).ref(),
			value <- thisModule.StateSymbol(ci.classifier, et.target).ref()
		)
}

helper context AADL!ComponentInstance def: guardExpression(et: EMV2!ErrorBehaviorTransition): AR!Expression =
	let condition: EMV2!ConditionElement = et.condition in
	let inProp: EMV2!ErrorPropagation = condition.qualifiedErrorPropagationReference.errorPropagation in
	let otherProps: Sequence(EMV2!ErrorPropagation) = self.classifier.incomingErrorPropagations() -> excluding(inProp) in
	let propGuard: AR!Expression = self.inPropGuard(condition, inProp) in
	if otherProps.isEmpty() then
		propGuard
	else
		thisModule.And(propGuard, self.allNoError(otherProps))
	endif;

--- Create a guard expression fragment from an in propagation
helper context AADL!ComponentInstance def: inPropGuard(condition: EMV2!ConditionElement, inProp: EMV2!ErrorPropagation): AR!Expression =
	let inFlows: Sequence(AR!Variable) = thisModule.ep2flows.get(Tuple{io = self, prop = inProp}) in
	condition.orOfFlows(inFlows);

helper context EMV2!ConditionElement def: orOfFlows(flows: Sequence(AR!Variable)): AR!Expression =
	let head: AR!Variable = flows->at(1) in
	let constants: Sequence(AR!SymbolicConstant) = 
		self.leafTokens()
		->collect(t | head.constant(t))
		->select(c | not c.oclIsUndefined()) in
	let exp: AR!Expression = head.orOfConstants(constants) in
	if flows->size() = 1 then
		exp
	else
		let tailExp: AR!Expression = self.orOfFlows(flows->tail()) in
		if exp.oclIsUndefined() then
			tailExp
		else
			thisModule.Or(exp, tailExp)
		endif
	endif;

helper context AR!Variable def: orOfConstants(constants: Sequence(AR!SymbolicConstant)): AR!Expression =
	if constants->isEmpty() then
		let flow: AR!Variable = self in
		thisModule.NotEqual(self, flow.noError) 
	else 
		let head: AR!SymbolicConstant = constants->at(1) in
		let exp: AR!Expression = thisModule.Equal(self, head) in
		if constants->size() <= 1 then
			exp
		else
			let tailExp: AR!Expression = self.orOfConstants(constants->tail()) in
			if exp.oclIsUndefined() then
				tailExp
			else
				thisModule.Or(exp, tailExp)
			endif
		endif
	endif;

--- Create a guard expression fragment for a set of in propagations that must be error free
helper context AADL!ComponentInstance def: allNoError(eps: Sequence(EMV2!ErrorPropagation)): AR!Expression =
	let head: EMV2!ErrorPropagation = eps -> first() in
	let inFlows: Sequence(AR!Variable) = thisModule.ep2flows.get(Tuple{io = self, prop = head}) in
	let exp: AR!Expression = thisModule.allNoError(inFlows) in
	if eps -> size() = 1 then
		exp
	else
		thisModule.And(exp, self.allNoError(eps -> tail()))
	endif;
	
helper def: allNoError(flows: Sequence(AR!Variable)): AR!Expression =
	let head: AR!Variable = flows->at(1) in -- ATL bug: first() throws exception
	let exp: AR!Expression = thisModule.Equal(head, head.noError) in
	if flows -> size() = 1 then
		exp
	else
		thisModule.And(exp, thisModule.allNoError(flows -> tail()))
	endif;
	
helper context Sequence(OclAny) def: tail(): Sequence(OclAny) =
	self.subSequence(2, self -> size());

lazy rule Or {
	from
		left: AR!Expression,
		right: AR!Expression
	to
		a: AR!Logical (
			left <- left,
			op <-'or',
			right <- right
		)
}

lazy rule And {
	from
		left: AR!Expression,
		right: AR!Expression
	to
		a: AR!Logical (
			left <- left,
			op <-'and',
			right <- right
		)
}

lazy rule Equal {
	from
		inflow: AR!Variable,
		value: AR!SymbolicConstant
	to
		eq: AR!Equal (
			left <- inflow.ref(),
			op <- '==',
			right <- value.ref()
		)
}

lazy rule NotEqual {
	from
		inflow: AR!Variable,
		value: AR!SymbolicConstant
	to
		eq: AR!Equal (
			left <- inflow.ref(),
			op <- '!=',
			right <- value.ref()
		)
}

-- a bool or integer

lazy rule BaseType {
	from
		kind: AR!BaseTypeEnum
	to
	  p: AR!BaseType (
	  	name <- kind
		)
}


helper context AADL!ComponentInstance def: internalAssertions(): Sequence(AR!Instruction) =
	Sequence{};

-- external assertions (at same level as connection, or at top level for bindings)
helper context AADL!ComponentInstance def: externalAssertions(): Sequence(AR!Instruction) =
	if thisModule.ci2paths.getKeys() -> includes(self) then 
		thisModule.ci2paths.get(self) -> select(pp | not pp.isConnectionBindingPath()) -> collect(pp | pp.makeAssertion())
	else
		Sequence{}
	endif;

helper context "#native"!"org::osate::xtext::aadl2::errormodel::util::PropagationPathRecord" 
		def: makeAssertion(): AR!Instruction =
	let container: AADL!ComponentInstance = self.assertionContainer in
	let srcCi: AADL!ComponentInstance = self.getPathSrc().getComponentInstance() in
	let dstCi: AADL!ComponentInstance = self.getPathDst().getComponentInstance() in
	let srcFlow: AR!Variable = thisModule.OutFlow(srcCi, self.getPathSrc().getErrorPropagation()) in
	let dstFlow: AR!Variable = thisModule.InFlow(dstCi, self) in
	thisModule.Assignment(thisModule.NameRef(dstFlow, dstCi, container), thisModule.NameRef(srcFlow, srcCi, container));

lazy rule Assignment {
	from
		variable: AR!NameRef,
		value: AR!NameRef
	to
		i: AR!Assignment (
			variable <- variable,
			value <- value
		)
}
	
lazy rule NameRef {
	from
		var: AR!Variable,
		owner: AADL!ComponentInstance,
		upto: AADL!ComponentInstance
	to
		ref: AR!NameRef (
			variable <- var,
			nested <-
					let parent: AADL!ComponentInstance = owner.refImmediateComposite() in
					if parent = upto then		
						owner.nodeInstance.ref()
					else
						thisModule.NameRef(owner.nodeInstance, parent)
					endif
		)
}

helper context AR!NamedElement def: ref(): AR!NameRef =
	thisModule.LeafNameRef(self);

lazy rule LeafNameRef {
	from
		var: AR!NamedElement
	to
		ref: AR!NameRef (
			variable <- var
		)
}
