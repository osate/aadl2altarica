-- @atlcompiler emftvm
-- @nsURI AR=http://osate.org/Altarica/2.1
-- @nsURI AADL=http://aadl.info/AADL/2.0/instance
-- @nsURI AADL2=http://aadl.info/AADL/2.0
-- @nsURI EMV2=http://www.aadl.info/EMV2


module AADLEM2AltaRica;
create OUT: AR from IN: AADL;

uses Util;

-- Nodes must be declared before use
rule SystemInstance {
	from
		si: AADL!SystemInstance
	to
		m: AR!Model (
		)
	do {
		thisModule.Node(si);
	}
}

-- helper to collect created domains
helper def: domains: Sequence(AR!Domain) = Sequence{};

-- helper to collect created classes
helper def: classes: Sequence(AR!Node) = Sequence{};

endpoint rule Finish() {
	using {
		m: AR!Model = thisModule.traces.getDefaultSourceElements()
			-> collect(e | e.getObject())
			-> any(o | o.oclIsKindOf(AADL!SystemInstance)).resolve();
	}
	do {
		m.declarations <- 
				thisModule.domains -> append(thisModule.classes) -> flatten();
--		thisModule.analysisModel.printPropagationPaths();
		'done'.debug();
	}
}

unique lazy rule Node {
	from	
		ci: AADL!ComponentInstance
  using {
		c: AADL2!ComponentClassifier = ci.classifier;
		hasPropagations: Sequence(EMV2!ErrorPropagation) = 
			not (c.oclIsUndefined() or c.errorPropagations().isEmpty());
  }
	to
		node: AR!Node (
			name <- c.name.normalizeId() + '_' + thisModule.classes -> size().toString(),
			-- need to force declarations because assertions need containment structure in place
			declarations <- ci.subnodes() -> force() ->
					append(ci.events()) -> append(ci.states()) -> append(ci.flows()) -> flatten(),
			transitions <- ci.transitions(),
			assertions <- ci.internalAssertions() -> append(ci.externalAssertions()) -> flatten()
		)
	do {
		thisModule.classes <:= thisModule.classes -> prepend(node);
		node;
	}
}

-- the contained node instances
helper context AADL!ComponentInstance def: subnodes(): Sequence(AR!Variable) =
	if self.isLeaf then Sequence{}
	else self.componentInstance -> collect(sub | sub.nodeInstance) endif;

-- the node instance in AltaRica corresponding to this component instance in AADL
helper context AADL!ComponentInstance def: nodeInstance: AR!Variable = thisModule.NodeInstance(self);

unique lazy rule NodeInstance {
	from
		sub: AADL!ComponentInstance
	to
		ni: AR!Variable (
			name <- sub.name,
			type <- classType 
		),
	  classType: AR!NamedType (
	  	ref <- thisModule.Node(sub)
		)
}

-- events
-- TODO: handle typed error events

helper context AADL!ComponentInstance def: events(): Sequence(AR!Variable) =
	self.classifier.errorEvents() -> collect(event | thisModule.Event(self, event)) -> append(thisModule.ImmediateEvent(self));

unique lazy rule Event {
	from
		ci: AADL!ComponentInstance,
		e: EMV2!ErrorBehaviorEvent
	to
		event: AR!Event (
			name <- e.altaRicaName()
		)
}

unique lazy rule ImmediateEvent {
	from 
		ci: AADL!ComponentInstance
	to
		event: AR!Event (
			name <- 'error_propagation',
			attributes <- Sequence{delay}
		),
		delay: AR!Attribute (
			name <- 'delay',
			value <- zero
		),
		zero: AR!ARInteger (
			value <- 0
		)
}
-- states
-- TODO: handle typed error states

helper context AADL!ComponentInstance def: states(): Sequence(AR!Variable) =
	let state: AR!Variable = thisModule.State(self) in
	if state.oclIsUndefined() then 
		Sequence{}
	else 
		Sequence{state}
	endif;

unique lazy rule State {
	from
		ci: AADL!ComponentInstance (
			ci.classifier.errorStates() -> notEmpty()
		)
	to
		state: AR!Variable (
			name <- 'errorstate',
			type <- thisModule.StateDomainType(ci),
			attributes <- Sequence{init}
		),
		init: AR!Attribute (
			name <- 'init',
			value <- thisModule.LeafNameRef(ci.classifier.initialState())
		)
}

--- Get the initial error state
helper context AADL2!ComponentClassifier def: initialState(): AR!SymbolicConstant =
	let state: EMV2!ErrorBehaviorState = self.errorStates() -> any(s | s.isInitial()) in
	thisModule.StateSymbol(self, state);

--- Workaround for typo in EMV2 grammar
helper context EMV2!ErrorBehaviorState def: isInitial(): Boolean = self.isIntial();

lazy rule StateDomainType {
	from
		ci: AADL!ComponentInstance
	to
		domainType: AR!NamedType (
			ref <- thisModule.StateDomain(ci.classifier)
		)
}

-- map to keep track of type tokens in domains
--helper def: domain2tokens: Map(AR!Domain, Set(EMV2!TypeToken)) = Map{};

--- doc
unique lazy rule StateDomain {
	from
		c: AADL!ComponentClassifier
	using {
		count: Integer = thisModule.domainCount;
	}
	to
		domain: AR!Domain (
			name <- 'domain_' + count.toString(),
			constants <- c.createSymbols()
		)
	do {
		thisModule.domainCount <:= count + 1;
		thisModule.domains <:= thisModule.domains -> append(domain);
		domain;
	}
}
	
--- Create the symbols for the domain of the error propagation
helper context AADL2!ComponentClassifier def: createSymbols(): Sequence(AR!SymbolicConstant) =
	self.errorStates() -> collect(s | thisModule.StateSymbol(self, s));

unique lazy rule StateSymbol {
	from
		c: AADL2!ComponentClassifier,
		state: EMV2!ErrorBehaviorState
	to 
		const: AR!SymbolicConstant (
			name <- state.altaRicaName()
		)
}

-- flow variables

helper context AADL!ComponentInstance def: flows(): Sequence(AR!Variable) =
	let outFlows: Sequence(AR!Variable) = 
		self.classifier.outgoingErrorPropagations() -> collect(oep | thisModule.OutFlow(self, oep)) in
	let inFlows: Sequence(AR!Variable) = 
		self.classifier.incomingErrorPropagations() ->
				collect(iep | thisModule.dst2paths.get(Tuple{io = self, prop = iep}) -> collect(path | thisModule.InFlow(self, path))) in
	outFlows -> append(inFlows);

-- map to keep track of flow variables created for propagations in a component instance
helper def: ep2flows: Map(TupleType(io: AADL!ComponentInstance, prop: EMV2!ErrorPropagation), Sequence(AR!Variable)) = Map{};

unique lazy rule OutFlow {
	from
		ci: AADL!ComponentInstance,
		prop: EMV2!ErrorPropagation
	to
		flow: AR!Variable (
			name <- prop.altaRicaName(),
			type <- thisModule.FlowDomainType(prop),
			attributes <- Sequence{reset}
		),
		reset: AR!Attribute (
			name <- 'reset',
			value <- thisModule.LeafNameRef(thisModule.NoError(thisModule.FlowDomain(prop)))
		)
	do {
		thisModule.ep2flows <:= thisModule.ep2flows -> 
				including(Tuple{io = ci, prop = prop}, Sequence{flow});
		flow;
	}
}

unique lazy rule InFlow {
	from
		ci: AADL!ComponentInstance,
		path: "#native"!"org::osate::xtext::aadl2::errormodel::util::PropagationPathRecord"
	using {
		count: Integer = thisModule.inCount;
		prop: EMV2!ErrorPropagation = path.getPathDst().getErrorPropagation();
	}
	to
		flow: AR!Variable (
			name <- prop.indexedName(count),
			type <-
					let srcProp: EMV2!ErrorPropagation = path.getPathSrc().getErrorPropagation() in
					thisModule.FlowDomainType(srcProp)
		)
	do {
		if (thisModule.ep2flows.getKeys() -> includes(Tuple{io = ci, prop = prop})) {
			thisModule.ep2flows <:= thisModule.ep2flows -> 
					including(
							Tuple{io = ci, prop = prop}, 
							thisModule.ep2flows.get(Tuple{io = ci, prop = prop}) -> append(flow)
					);
		} else {
			thisModule.ep2flows <:= thisModule.ep2flows -> 
					including(Tuple{io = ci, prop = prop}, Sequence{flow});
		}
		thisModule.inCount <:= count + 1;
		flow;
	}
}
-- counter for in flow variable names to avoid duplicates
helper def: inCount: Integer = 0;

lazy rule FlowDomainType {
	from
		prop: EMV2!ErrorPropagation
	to
		domainType: AR!NamedType (
			ref <- thisModule.FlowDomain(prop)
		)
}

-- map to keep track of type tokens in domains
--helper def: domain2tokens: Map(AR!Domain, Set(EMV2!TypeToken)) = Map{};

--- doc
unique lazy rule FlowDomain {
	from
		prop: EMV2!ErrorPropagation
	using {
		count: Integer = thisModule.domainCount;
	}
	to
		domain: AR!Domain (
			name <- 'domain_' + count.toString(),
			constants <- prop.createSymbols() -> prepend(thisModule.NoError(domain))
		)
	do {
		thisModule.domainCount <:= count + 1;
		thisModule.domains <:= thisModule.domains -> append(domain);
		--thisModule.domain2tokens <:= thisModule.domain2tokens -> including(domain, prop.leafTokens() -> asSet());
		domain;
	}
}

helper def: domainCount: Integer = 0;

--- Get the leaf error tokens associated with an error propagation
helper context EMV2!ErrorPropagation def: leafTokens(): Sequence(EMV2!TypeToken) =
	let usedTypes: Sequence(EMV2!ErrorModelLibrary) = self.containingClassifier().usedTypes() in
	self.typeSet.leafTypeTokens(usedTypes);

--- Create the symbols for the domain of the error propagation
helper context EMV2!ErrorPropagation def: createSymbols(): Sequence(AR!SymbolicConstant) =
	self.leafTokens() -> collect(t | thisModule.SymbolicConstant(t));
	
lazy rule SymbolicConstant {
	from
		token: EMV2!TypeToken
	to 
		const: AR!SymbolicConstant (
			name <- '\'' + token.name() + '\''
		)
}

unique lazy rule NoError {
	from 
		domain: AR!Domain
	to
		noError: AR!SymbolicConstant (
			name <- 'no_error'
		)
}

-- transitions

helper context EMV2!ConditionExpression def: isSingleEvent(): Boolean =
	self.oclIsTypeOf(EMV2!ConditionElement) and self.constraint.oclIsUndefined() and self.qualifiedErrorPropagationReference.emv2Target.namedElement.oclIsTypeOf(EMV2!ErrorEvent);

helper context AADL!ComponentInstance def: transitions(): Sequence(AR!LabeledTransition) =
	let transitions: Collection(EMV2!ErrorBehaviorTransition) = self.classifier.errorTransitions() in
	let handled_events: Collection(EMV2!ErrorBehaviorTransition) = 
		transitions -> select(t |
			not (t.source.oclIsUndefined() or t.target.oclIsUndefined()) and t.condition.isSingleEvent()
		) in
	let handled_props: Collection(EMV2!ErrorBehaviorTransition) =
		transitions -> select(t |
			not (t.source.oclIsUndefined() or t.target.oclIsUndefined()) and not t.condition.isSingleEvent()
		)
	in
		handled_events -> collect(t | thisModule.EventTransition(self, t.debug('processing et ')))
	;

lazy rule EventTransition {
	from
		ci: AADL!ComponentInstance,
		et: EMV2!ErrorBehaviorTransition
	to
		lt: AR!LabeledTransition (
			event <- let event: AR!Event = thisModule.Event(ci, et.condition.qualifiedErrorPropagationReference.emv2Target.namedElement.debug('ne ')) in
					thisModule.LeafNameRef(event),
			expression <- te
		),
		te: AR!Transition (
			guard <- g,
			action <- a
		),
		g: AR!Equal (
			left <- thisModule.LeafNameRef(thisModule.State(ci)).debug('guard state '),
			op <- '=',
			right <- thisModule.LeafNameRef(thisModule.StateSymbol(ci.classifier, et.source)).debug('guard symbol ')
		),
		a: AR!Assignment (
			variable <- thisModule.LeafNameRef(thisModule.State(ci)).debug('assign state '),
			value <- thisModule.LeafNameRef(thisModule.StateSymbol(ci.classifier, et.target)).debug('assign symbol ')
		)
}

lazy rule PropagationTransition {
	from
		ci: AADL!ComponentInstance,
		et: EMV2!ErrorBehaviorTransition
	to
		lt: AR!LabeledTransition (
			event <- let event: AR!Event = thisModule.Event(ci, et.condition.qualifiedErrorPropagationReference.emv2Target.namedElement.debug('ne ')) in
					thisModule.LeafNameRef(event),
			expression <- te
		),
		te: AR!Transition (
			guard <- g,
			action <- a
		),
		g: AR!Equal (
			left <- thisModule.LeafNameRef(thisModule.State(ci)).debug('guard state '),
			op <- '=',
			right <- thisModule.LeafNameRef(thisModule.StateSymbol(ci.classifier, et.source)).debug('guard symbol ')
		),
		a: AR!Assignment (
			variable <- thisModule.LeafNameRef(thisModule.State(ci)).debug('assign state '),
			value <- thisModule.LeafNameRef(thisModule.StateSymbol(ci.classifier, et.target)).debug('assign symbol ')
		)
}

-- internal assertions

helper context AADL!ComponentInstance def: internalAssertions(): Sequence(AR!Instruction) =
	Sequence{};

	-- a bool or integer

lazy rule BaseType {
	from
		kind: AR!BaseTypeEnum
	to
	  p: AR!BaseType (
	  	name <- kind
		)
}

-- external assertions (at same level as connection, or at top level for bindings)

helper context AADL!ComponentInstance def: externalAssertions(): Sequence(AR!Instruction) =
	if thisModule.ci2paths.getKeys() -> includes(self) then 
		thisModule.ci2paths.get(self) -> select(pp | not pp.isConnectionBindingPath()) -> collect(pp | pp.makeAssertion())
	else
		Sequence{}
	endif;

helper context "#native"!"org::osate::xtext::aadl2::errormodel::util::PropagationPathRecord" 
		def: makeAssertion(): AR!Instruction =
	let container: AADL!ComponentInstance = self.assertionContainer in
	let srcCi: AADL!ComponentInstance = self.getPathSrc().getComponentInstance() in
	let dstCi: AADL!ComponentInstance = self.getPathDst().getComponentInstance() in
	let srcFlow: AR!Variable = thisModule.OutFlow(srcCi, self.getPathSrc().getErrorPropagation()) in
	let dstFlow: AR!Variable = thisModule.InFlow(dstCi, self) in
	thisModule.Assignment(thisModule.NameRef(dstFlow, dstCi, container), thisModule.NameRef(srcFlow, srcCi, container));

lazy rule Assignment {
	from
		variable: AR!NameRef,
		value: AR!NameRef
	to
		i: AR!Assignment (
			variable <- variable,
			value <- value
		)
}
	
lazy rule NameRef {
	from
		var: AR!Variable,
		owner: AADL!ComponentInstance,
		upto: AADL!ComponentInstance
	to
		ref: AR!NameRef (
			variable <- var,
			nested <-
					let parent: AADL!ComponentInstance = owner.refImmediateComposite() in
					if parent = upto then		
						thisModule.LeafNameRef(owner.nodeInstance)
					else
						thisModule.NameRef(owner.nodeInstance, parent)
					endif
		)
}

lazy rule LeafNameRef {
	from
		var: AR!NamedElement
	to
		ref: AR!NameRef (
			variable <- var
		)
}

