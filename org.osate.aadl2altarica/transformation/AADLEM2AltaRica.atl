-- @atlcompiler emftvm
-- @nsURI AR=http://osate.org/Altarica/2.1
-- @nsURI AADL=http://aadl.info/AADL/2.0/instance
-- @nsURI AADL2=http://aadl.info/AADL/2.0
-- @nsURI EMV2=http://www.aadl.info/EMV2


module AADLEM2AltaRica;
create OUT: AR from IN: AADL;

uses Util;

-- Nodes must be declared before use
rule SystemInstance {
	from
		si: AADL!SystemInstance
	to
		m: AR!Model (
		)
	do {
		thisModule.Node(si);
	}
}

-- helper to collect created domains
helper def: domains: Sequence(AR!Domain) = Sequence{};

-- helper to collect created classes
helper def: classes: Sequence(AR!Node) = Sequence{};

endpoint rule Finish() {
	using {
		m: AR!Model = thisModule.traces.getDefaultSourceElements()
			-> collect(e | e.getObject())
			-> any(o | o.oclIsKindOf(AADL!SystemInstance)).resolve();
	}
	do {
		m.declarations <- 
				thisModule.domains -> append(thisModule.classes) -> flatten();
--		thisModule.analysisModel.printPropagationPaths();
		'done'.debug();
	}
}

unique lazy rule Node {
	from	
		ci: AADL!ComponentInstance
  using {
		c: AADL2!ComponentClassifier = ci.componentClassifier;
		hasPropagations: Sequence(EMV2!ErrorPropagation) = 
			not (c.oclIsUndefined() or c.errorPropagations().isEmpty());
  }
	to
		node: AR!Node (
			name <- c.name.normalizeId() + '_' + thisModule.classes -> size().toString(),
			-- need to force declarations because assertions need containment structure in place
			declarations <- ci.subnodes() -> append(ci.flows()) -> flatten() -> force(),
			assertions <- ci.assertions()
		)
	do {
		thisModule.classes <:= thisModule.classes -> append(node);
		node;
	}
}

-- the contained node instances
helper context AADL!ComponentInstance def: subnodes(): Sequence(AR!Variable) =
	if self.isLeaf then Sequence{}
	else self.componentInstance -> collect(sub | sub.nodeInstance) endif;

-- the node instance in AltaRica corresponding to this component instance in AADL
helper context AADL!ComponentInstance def: nodeInstance: AR!Variable = thisModule.NodeInstance(self);

unique lazy rule NodeInstance {
	from
		sub: AADL!ComponentInstance
	to
		ni: AR!Variable (
			name <- sub.name,
			type <- classType 
		),
	  classType: AR!NamedType (
	  	ref <- thisModule.Node(sub)
		)
}

-- flow variables

helper context AADL!ComponentInstance def: flows(): Sequence(AR!Variable) =
	let outFlows: Sequence(AR!Variable) = 
		self.componentClassifier.outgoingErrorPropagations() -> collect(oep | thisModule.OutFlow(self, oep)) in
	let inFlows: Sequence(AR!Variable) = 
		self.componentClassifier.incomingErrorPropagations() ->
				collect(iep | thisModule.dst2paths.get(Tuple{io = self, prop = iep}) -> collect(path | thisModule.InFlow(self, path))) in
	outFlows -> append(inFlows);
	

unique lazy rule OutFlow {
	from
		ci: AADL!ComponentInstance,
		propagation: EMV2!ErrorPropagation
	to
		f: AR!Variable (
			name <- propagation.altaRicaName(),
			type <- thisModule.DomainType(propagation)
		)
}

unique lazy rule InFlow {
	from
		ci: AADL!ComponentInstance,
		path: "#native"!"org::osate::xtext::aadl2::errormodel::util::PropagationPathRecord"
	using {
		count: Integer = thisModule.inCount;
	}
	to
		flow: AR!Variable (
			name <- 
					let dstProp: EMV2!ErrorPropagation = path.getPathDst().getErrorPropagation() in
					dstProp.indexedName(count),
			type <-
					let srcProp: EMV2!ErrorPropagation = path.getPathSrc().getErrorPropagation() in
					thisModule.DomainType(srcProp)
		)
	do {
		thisModule.inCount <:= count + 1;
		flow;
	}
}
-- counter for in flow variable names to avoid duplicates
helper def: inCount: Integer = 0;

lazy rule DomainType {
	from
		prop: EMV2!ErrorPropagation
	to
		domainType: AR!NamedType (
			ref <- thisModule.Domain(prop)
		)
}

unique lazy rule Domain {
	from
		prop: EMV2!ErrorPropagation
	using {
		count: Integer = thisModule.domainCount;
	}
	to
		domain: AR!Domain (
			name <- 'domain_' + count.toString(),
			domain <- enum
		),
		enum: AR!Enumeration (
			ownedSymbols <- prop.createSymbols()
		)
	do {
		thisModule.domainCount <:= count + 1;
		thisModule.domains <:= thisModule.domains -> append(domain);
		domain;
	}
}

helper def: domainCount: Integer = 0;

helper context EMV2!ErrorPropagation def: createSymbols(): Sequence(AR!SymbolicConstant) =
	let usedTypes: Sequence(EMV2!ErrorModelLibrary) = self.containingClassifier().usedTypes() in
	let tokens: Sequence(EMV2!TypeToken) = self.typeSet.leafTypeTokens(usedTypes) in
	tokens -> collect(t | thisModule.SymbolicConstant(t));

lazy rule SymbolicConstant {
	from
		token: EMV2!TypeToken
	to 
		const: AR!SymbolicConstant (
			name <- '\'' + token.name() + '\''
		)
}
-- a bool or integer

lazy rule BaseType {
	from
		kind: AR!BaseTypeEnum
	to
	  p: AR!BaseType (
	  	name <- kind
		)
}

-- external assertions (at top level)

helper context AADL!ComponentInstance def: assertions(): Sequence(AR!Instruction) =
	if self.oclIsTypeOf(AADL!SystemInstance) then
		thisModule.propagationPaths -> 
				select(pp | not pp.isConnectionBindingPath()) -> 
				collect(pp | pp.makeAssertion())
	else
		Sequence{}
  endif;
  
helper context "#native"!"org::osate::xtext::aadl2::errormodel::util::PropagationPathRecord" 
		def: makeAssertion(): AR!Instruction =
	let srcCi: AADL!ComponentInstance = self.getPathSrc().getComponentInstance() in
	let dstCi: AADL!ComponentInstance = self.getPathDst().getComponentInstance() in
	let srcFlow: AR!Variable = thisModule.OutFlow(srcCi, self.getPathSrc().getErrorPropagation()) in
	let dstFlow: AR!Variable = thisModule.InFlow(dstCi, self) in
	thisModule.Assignment(thisModule.NameRef(dstFlow, dstCi), thisModule.NameRef(srcFlow, srcCi));

lazy rule Assignment {
	from
		variable: AR!NameRef,
		value: AR!NameRef
	to
		i: AR!Assignment (
			variable <- variable,
			value <- value
		)
}
	
lazy rule NameRef {
	from
		var: AR!Variable,
		owner: AADL!ComponentInstance
	to
		ref: AR!NameRef (
			variable <- var,
			nested <- 
					let parent: AADL!ComponentInstance = owner.refImmediateComposite() in
					if parent.oclIsTypeOf(AADL!SystemInstance) then		
						thisModule.LeafNameRef(owner.nodeInstance)
					else
						thisModule.NameRef(owner.nodeInstance, parent)
					endif
		)
}

lazy rule LeafNameRef {
	from
		var: AR!Variable
	to
		ref: AR!NameRef (
			variable <- var
		)
}

