-- @atlcompiler emftvm
-- @nsURI AR=http://osate.org/Altarica/2.1
-- @nsURI AADL=http://aadl.info/AADL/2.0/instance
-- @nsURI AADL2=http://aadl.info/AADL/2.0
-- @nsURI EMV2=http://www.aadl.info/EMV2


module AADLEM2AltaRica;
create OUT: AR from IN: AADL;

uses Util;

-- Nodes must be declared before use
rule SystemInstance {
	from
		si: AADL!SystemInstance
	to
		m: AR!Model (
		)
	do {
		thisModule.MakeNode(si.componentClassifier, si);
	}
}

endpoint rule Finish() {
	using {
		m: AR!Model = thisModule.traces.getDefaultSourceElements()
			-> collect(e | e.getObject())
			-> any(o | o.oclIsKindOf(AADL!SystemInstance)).resolve();
	}
	do {
		m.declarations <- thisModule.createdClasses -> reverse();
		thisModule.analysisModel.printPropagationPaths();
		'done'.debug();
	}
}

-- TODO: simplify this
-- Create a node for the referenced classifier
lazy rule MakeNode {
	from
		c: AADL2!ComponentClassifier,
	  ci: AADL!ComponentInstance (
	  	not thisModule.processedClassifiers -> contains(c)
	  )
  using {
		n: AR!Node = thisModule.Node(c);
		declarations: Sequence(AR!Declaration) = Sequence{};
		subs: Sequence(AADL!ComponentInstance) = ci.componentInstance;
		eps: Sequence(EMV2!ErrorPropagation) = c.errorPropagations();
  }
	do {
		-- fill in sub nodes
		if (not ci.isLeaf and not subs.isEmpty()) {
			declarations <- declarations -> append(thisModule.subNodes(subs));
		}
		-- fill in flow variables
		if (not eps.isEmpty()) {
			declarations <- declarations -> append(c.flows());
		}
		n.declarations <- declarations -> flatten();

		if (ci.oclIsTypeOf(AADL!SystemInstance)) {
			n.assertions <- thisModule.assertions();
		}
		-- process each referenced classifier only once
		thisModule.processedClassifiers <:= thisModule.processedClassifiers -> including(c);
		n;
	}
}

helper def: processedClassifiers: Set(AADL2!ComponentClassifier) = Set{};

helper def: createdClasses: Sequence(AR!Node) = Sequence{};

-- Need this a a separate rule to resolve classifier
unique lazy rule Node {
	from	
		c: AADL2!ComponentClassifier
	to
		node: AR!Node (
			name <- c.debug().getQualifiedName().normalizeId()
		)
	do {
		thisModule.createdClasses <:= thisModule.createdClasses -> append(node);
		node;
	}
}

-- the contained node instances
helper def: subNodes(subs: Sequence(AADL!ComponentInstance)): Sequence(AR!Variable) =
	subs -> collect(s | s.nodeInstance);

-- the node instance in AltaRica that corresponding to this component instance in AADL
helper context AADL!ComponentInstance def: nodeInstance: AR!Variable =
	let c: AADL2!ComponentClassifier = self.componentClassifier in
	let type: AR!ClassType = 
			let referenced: AR!Node = 
					if thisModule.processedClassifiers -> contains(c) then
						thisModule.Node(c)
					else
						thisModule.MakeNode(c, self)
					endif
			in
				thisModule.ClassType(referenced)
	in
		thisModule.NodeInstance(self.subcomponent);
	
unique lazy rule NodeInstance {
	from
		sub: AADL2!Subcomponent
	to
		ni: AR!Variable (
			name <- sub.name.debug('Node instance in ' + sub.eContainer().name),
			type <- 
					let referenced: AR!Node = thisModule.Node(sub.getAllClassifier()) in
					thisModule.ClassType(referenced)
		)
}

lazy rule ClassType {
	from
		node: AR!Node
	to
	  type: AR!ClassType (
	  	class <- node
		)
}

-- flow variables
helper context AADL2!ComponentClassifier def: flows(): Sequence(AR!Variable) =
	self.errorPropagations() -> collect(ep | thisModule.Flow(ep));

unique lazy rule Flow {
	from
		propagation: EMV2!ErrorPropagation
	to
		f: AR!Variable (
			type <- thisModule.BaseType(thisModule.int),
			name <- propagation.getFeatureorPPRef().altaRicaName()
		)
}

-- a bool or integer
lazy rule BaseType {
	from
		kind: AR!BaseTypeEnum
	to
	  p: AR!BaseType (
	  	name <- kind
		)
}

-- assertions (at top level)

helper def: assertions(): Sequence(AR!Instruction) =
	thisModule.propagationPaths -> 
			select(pp | pp.isConnectionPath()) -> 
			collect(pp | pp.makeAssertion());

helper context "#native"!"org::osate::xtext::aadl2::errormodel::util::PropagationPathRecord" def: makeAssertion(): AR!Instruction =
	let srcFlow: AR!NamedElement = thisModule.Flow(self.getPathSrc().getErrorPropagation()) in
	let dstFlow: AR!NamedElement = thisModule.Flow(self.getPathDst().getErrorPropagation()) in
	let srcCi: AADL!ComponentInstance = self.getPathSrc().getComponentInstance() in
	let dstCi: AADL!ComponentInstance = self.getPathDst().getComponentInstance() in
	thisModule.Assignment(thisModule.NameRef(dstFlow, dstCi), thisModule.NameRef(srcFlow, srcCi));

lazy rule Assignment {
	from
		variable: AR!NameRef,
		value: AR!NameRef
	to
		i: AR!Assignment (
			variable <- variable,
			value <- value
		)
}
	
lazy rule NameRef {
	from
		var: AR!Variable,
		owner: AADL!ComponentInstance
	to
		ref: AR!NameRef (
			variable <- var.debug(),
			nested <- 
					let parent: AADL!ComponentInstance = owner.refImmediateComposite() in
					if parent.oclIsTypeOf(AADL!SystemInstance) then		
						thisModule.LeafNameRef(owner.nodeInstance)
					else
						thisModule.NameRef(owner.nodeInstance, parent)
					endif
		)
}

lazy rule LeafNameRef {
	from
		var: AR!Variable
	to
		ref: AR!NameRef (
			variable <- var.debug()
		)
}

